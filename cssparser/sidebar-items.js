window.SIDEBAR_ITEMS = {"enum":[["AngleOrNumber","Either an angle or a number."],["AtRuleType","The return value for `AtRuleParser::parse_prelude`. Indicates whether the at-rule is expected to have a `{ /* ... */ }` block or end with a `;` semicolon."],["BasicParseErrorKind","Details about a `BasicParseError`"],["Color","A  value."],["NumberOrPercentage","Either a number or a percentage."],["ParseErrorKind","Details of a `ParseError`"],["Token","One of the pieces the CSS input is broken into."]],"fn":[["parse_color_keyword","Return the named color with the given name."],["parse_important","Parse `!important`."],["parse_nth","Parse the An+B notation, as found in the `:nth-child()` selector. The input is typically the arguments of a function, in which case the caller needs to check if the arguments’ parser is exhausted. Return `Ok((A, B))`, or `Err(())` for a syntax error."],["parse_one_declaration","Parse a single declaration, such as an `( /* ... */ )` parenthesis in an `@supports` prelude."],["parse_one_rule","Parse a single rule, such as for CSSOM’s `CSSStyleSheet.insertRule`."],["serialize_identifier","Write a CSS identifier, escaping characters as necessary."],["serialize_name","Write a CSS name, like a custom property name."],["serialize_string","Write a double-quoted CSS string token, escaping content as necessary."],["stylesheet_encoding","Determine the character encoding of a CSS stylesheet."]],"macro":[["_cssparser_internal_max_len",""],["ascii_case_insensitive_phf_map","Define a function `$name(&str) -> Option<&'static $ValueType>`"],["match_ignore_ascii_case","Expands to a `match` expression with string patterns, matching case-insensitively in the ASCII range."]],"mod":[["Delimiter","`Delimiters` constants."]],"struct":[["BasicParseError","The funamental parsing errors that can be triggered by built-in parsing routines."],["CowRcStr","A string that is either shared (heap-allocated and reference-counted) or borrowed."],["CssStringWriter","A `fmt::Write` adapter that escapes text for writing as a double-quoted CSS string. Quotes are not included."],["DeclarationListParser","Provides an iterator for declaration list parsing."],["Delimiters","A set of characters, to be used with the `Parser::parse_until*` methods."],["ParseError","Extensible parse errors that can be encountered by client parsing implementations."],["Parser","A CSS parser that borrows its `&str` input, yields `Token`s, and keeps track of nested blocks and functions."],["ParserInput","The owned input for a parser."],["ParserState","A capture of the internal state of a `Parser` (including the position within the input), obtained from the `Parser::position` method."],["RGBA","A color with red, green, blue, and alpha components, in a byte each."],["RuleListParser","Provides an iterator for rule list parsing."],["SourceLocation","The line and column number for a given position within the input."],["SourcePosition","A position from the start of the input, counted in UTF-8 bytes."],["TokenSerializationType","A category of token. See the `needs_separator_when_before` method."],["UnicodeRange","One contiguous range of code points."]],"trait":[["AtRuleParser","A trait to provide various parsing of at-rules."],["ColorComponentParser","A trait that can be used to hook into how `cssparser` parses color components, with the intention of implementing more complicated behavior."],["DeclarationParser","A trait to provide various parsing of declaration values."],["EncodingSupport","Abstraction for avoiding a dependency from cssparser to an encoding library"],["QualifiedRuleParser","A trait to provide various parsing of qualified rules."],["ToCss","Trait for things the can serialize themselves in CSS syntax."]]};