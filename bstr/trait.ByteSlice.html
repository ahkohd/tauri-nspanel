<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A trait that extends `&amp;[u8]` with string oriented methods."><title>ByteSlice in bstr - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-fa3bb1812debf86c.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="bstr" data-themes="" data-resource-suffix="" data-rustdoc-version="1.74.1 (a28077b28 2023-12-04)" data-channel="1.74.1" data-search-js="search-8be46b629f5f14a8.js" data-settings-js="settings-74424d7eec62a23e.js" ><script src="../static.files/storage-fec3eaa3851e447d.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-c5bd66d33317d69f.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-5d8b3c7633ad77ba.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../bstr/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a></nav><nav class="sidebar"><a class="logo-container" href="../bstr/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">ByteSlice</a></h2><div class="sidebar-elems"><section><h3><a href="#provided-methods">Provided Methods</a></h3><ul class="block"><li><a href="#method.as_bstr">as_bstr</a></li><li><a href="#method.as_bstr_mut">as_bstr_mut</a></li><li><a href="#method.bytes">bytes</a></li><li><a href="#method.char_indices">char_indices</a></li><li><a href="#method.chars">chars</a></li><li><a href="#method.contains_str">contains_str</a></li><li><a href="#method.ends_with_str">ends_with_str</a></li><li><a href="#method.escape_bytes">escape_bytes</a></li><li><a href="#method.fields_with">fields_with</a></li><li><a href="#method.find">find</a></li><li><a href="#method.find_byte">find_byte</a></li><li><a href="#method.find_byteset">find_byteset</a></li><li><a href="#method.find_char">find_char</a></li><li><a href="#method.find_iter">find_iter</a></li><li><a href="#method.find_non_ascii_byte">find_non_ascii_byte</a></li><li><a href="#method.find_not_byteset">find_not_byteset</a></li><li><a href="#method.from_os_str">from_os_str</a></li><li><a href="#method.from_path">from_path</a></li><li><a href="#method.is_ascii">is_ascii</a></li><li><a href="#method.is_utf8">is_utf8</a></li><li><a href="#method.last_byte">last_byte</a></li><li><a href="#method.lines">lines</a></li><li><a href="#method.lines_with_terminator">lines_with_terminator</a></li><li><a href="#method.make_ascii_lowercase">make_ascii_lowercase</a></li><li><a href="#method.make_ascii_uppercase">make_ascii_uppercase</a></li><li><a href="#method.repeatn">repeatn</a></li><li><a href="#method.replace">replace</a></li><li><a href="#method.replace_into">replace_into</a></li><li><a href="#method.replacen">replacen</a></li><li><a href="#method.replacen_into">replacen_into</a></li><li><a href="#method.reverse_bytes">reverse_bytes</a></li><li><a href="#method.reverse_chars">reverse_chars</a></li><li><a href="#method.rfind">rfind</a></li><li><a href="#method.rfind_byte">rfind_byte</a></li><li><a href="#method.rfind_byteset">rfind_byteset</a></li><li><a href="#method.rfind_char">rfind_char</a></li><li><a href="#method.rfind_iter">rfind_iter</a></li><li><a href="#method.rfind_not_byteset">rfind_not_byteset</a></li><li><a href="#method.rsplit_once_str">rsplit_once_str</a></li><li><a href="#method.rsplit_str">rsplit_str</a></li><li><a href="#method.rsplitn_str">rsplitn_str</a></li><li><a href="#method.split_once_str">split_once_str</a></li><li><a href="#method.split_str">split_str</a></li><li><a href="#method.splitn_str">splitn_str</a></li><li><a href="#method.starts_with_str">starts_with_str</a></li><li><a href="#method.to_ascii_lowercase">to_ascii_lowercase</a></li><li><a href="#method.to_ascii_uppercase">to_ascii_uppercase</a></li><li><a href="#method.to_os_str">to_os_str</a></li><li><a href="#method.to_os_str_lossy">to_os_str_lossy</a></li><li><a href="#method.to_path">to_path</a></li><li><a href="#method.to_path_lossy">to_path_lossy</a></li><li><a href="#method.to_str">to_str</a></li><li><a href="#method.to_str_lossy">to_str_lossy</a></li><li><a href="#method.to_str_lossy_into">to_str_lossy_into</a></li><li><a href="#method.to_str_unchecked">to_str_unchecked</a></li><li><a href="#method.trim_end_with">trim_end_with</a></li><li><a href="#method.trim_start_with">trim_start_with</a></li><li><a href="#method.trim_with">trim_with</a></li><li><a href="#method.utf8_chunks">utf8_chunks</a></li></ul><h3><a href="#foreign-impls">Implementations on Foreign Types</a></h3><ul class="block"><li><a href="#impl-ByteSlice-for-%5Bu8;+N%5D">[u8; N]</a></li><li><a href="#impl-ByteSlice-for-%5Bu8%5D">[u8]</a></li></ul><h3><a href="#implementors">Implementors</a></h3></section><h2><a href="index.html">In bstr</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Trait <a href="index.html">bstr</a>::<wbr><a class="trait" href="#">ByteSlice</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/bstr/ext_slice.rs.html#114-3075">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub trait ByteSlice: Sealed {
<details class="toggle type-contents-toggle"><summary class="hideme"><span>Show 59 methods</span></summary>    // Provided methods
    fn <a href="#method.as_bstr" class="fn">as_bstr</a>(&amp;self) -&gt; &amp;<a class="struct" href="struct.BStr.html" title="struct bstr::BStr">BStr</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.as_bstr_mut" class="fn">as_bstr_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="struct.BStr.html" title="struct bstr::BStr">BStr</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.from_os_str" class="fn">from_os_str</a>(os_str: &amp;<a class="struct" href="https://doc.rust-lang.org/1.74.1/std/ffi/os_str/struct.OsStr.html" title="struct std::ffi::os_str::OsStr">OsStr</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.from_path" class="fn">from_path</a>(path: &amp;<a class="struct" href="https://doc.rust-lang.org/1.74.1/std/path/struct.Path.html" title="struct std::path::Path">Path</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.to_str" class="fn">to_str</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;&amp;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html">str</a>, <a class="struct" href="struct.Utf8Error.html" title="struct bstr::Utf8Error">Utf8Error</a>&gt; { ... }
<span class="item-spacer"></span>    unsafe fn <a href="#method.to_str_unchecked" class="fn">to_str_unchecked</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html">str</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.to_str_lossy" class="fn">to_str_lossy</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/alloc/borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;'_, <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html">str</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.to_str_lossy_into" class="fn">to_str_lossy_into</a>(&amp;self, dest: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.74.1/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>) { ... }
<span class="item-spacer"></span>    fn <a href="#method.to_os_str" class="fn">to_os_str</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;&amp;<a class="struct" href="https://doc.rust-lang.org/1.74.1/std/ffi/os_str/struct.OsStr.html" title="struct std::ffi::os_str::OsStr">OsStr</a>, <a class="struct" href="struct.Utf8Error.html" title="struct bstr::Utf8Error">Utf8Error</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.to_os_str_lossy" class="fn">to_os_str_lossy</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/alloc/borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;'_, <a class="struct" href="https://doc.rust-lang.org/1.74.1/std/ffi/os_str/struct.OsStr.html" title="struct std::ffi::os_str::OsStr">OsStr</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.to_path" class="fn">to_path</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;&amp;<a class="struct" href="https://doc.rust-lang.org/1.74.1/std/path/struct.Path.html" title="struct std::path::Path">Path</a>, <a class="struct" href="struct.Utf8Error.html" title="struct bstr::Utf8Error">Utf8Error</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.to_path_lossy" class="fn">to_path_lossy</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/alloc/borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;'_, <a class="struct" href="https://doc.rust-lang.org/1.74.1/std/path/struct.Path.html" title="struct std::path::Path">Path</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.repeatn" class="fn">repeatn</a>(&amp;self, n: <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.74.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>&gt; <a href="#" class="tooltip" data-notable-ty="Vec&lt;u8&gt;">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.contains_str" class="fn">contains_str</a>&lt;B: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;&gt;(&amp;self, needle: B) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.bool.html">bool</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.starts_with_str" class="fn">starts_with_str</a>&lt;B: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;&gt;(&amp;self, prefix: B) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.bool.html">bool</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.ends_with_str" class="fn">ends_with_str</a>&lt;B: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;&gt;(&amp;self, suffix: B) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.bool.html">bool</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.find" class="fn">find</a>&lt;B: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;&gt;(&amp;self, needle: B) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.rfind" class="fn">rfind</a>&lt;B: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;&gt;(&amp;self, needle: B) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.find_iter" class="fn">find_iter</a>&lt;'h, 'n, B: ?<a class="trait" href="https://doc.rust-lang.org/1.74.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;&gt;(
        &amp;'h self,
        needle: <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.reference.html">&amp;'n B</a>
    ) -&gt; <a class="struct" href="struct.Find.html" title="struct bstr::Find">Find</a>&lt;'h, 'n&gt; <a href="#" class="tooltip" data-notable-ty="Find&lt;&#39;h, &#39;n&gt;">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.rfind_iter" class="fn">rfind_iter</a>&lt;'h, 'n, B: ?<a class="trait" href="https://doc.rust-lang.org/1.74.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;&gt;(
        &amp;'h self,
        needle: <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.reference.html">&amp;'n B</a>
    ) -&gt; <a class="struct" href="struct.FindReverse.html" title="struct bstr::FindReverse">FindReverse</a>&lt;'h, 'n&gt; <a href="#" class="tooltip" data-notable-ty="FindReverse&lt;&#39;h, &#39;n&gt;">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.find_byte" class="fn">find_byte</a>(&amp;self, byte: <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.rfind_byte" class="fn">rfind_byte</a>(&amp;self, byte: <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.find_char" class="fn">find_char</a>(&amp;self, ch: <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html">char</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.rfind_char" class="fn">rfind_char</a>(&amp;self, ch: <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html">char</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.find_byteset" class="fn">find_byteset</a>&lt;B: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;&gt;(&amp;self, byteset: B) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.find_not_byteset" class="fn">find_not_byteset</a>&lt;B: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;&gt;(&amp;self, byteset: B) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.rfind_byteset" class="fn">rfind_byteset</a>&lt;B: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;&gt;(&amp;self, byteset: B) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.rfind_not_byteset" class="fn">rfind_not_byteset</a>&lt;B: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;&gt;(&amp;self, byteset: B) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.fields_with" class="fn">fields_with</a>&lt;F: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html">char</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.bool.html">bool</a>&gt;(&amp;self, f: F) -&gt; <a class="struct" href="struct.FieldsWith.html" title="struct bstr::FieldsWith">FieldsWith</a>&lt;'_, F&gt; <a href="#" class="tooltip" data-notable-ty="FieldsWith&lt;&#39;_, F&gt;">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.split_str" class="fn">split_str</a>&lt;'h, 's, B: ?<a class="trait" href="https://doc.rust-lang.org/1.74.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;&gt;(
        &amp;'h self,
        splitter: <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.reference.html">&amp;'s B</a>
    ) -&gt; <a class="struct" href="struct.Split.html" title="struct bstr::Split">Split</a>&lt;'h, 's&gt; <a href="#" class="tooltip" data-notable-ty="Split&lt;&#39;h, &#39;s&gt;">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.rsplit_str" class="fn">rsplit_str</a>&lt;'h, 's, B: ?<a class="trait" href="https://doc.rust-lang.org/1.74.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;&gt;(
        &amp;'h self,
        splitter: <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.reference.html">&amp;'s B</a>
    ) -&gt; <a class="struct" href="struct.SplitReverse.html" title="struct bstr::SplitReverse">SplitReverse</a>&lt;'h, 's&gt; <a href="#" class="tooltip" data-notable-ty="SplitReverse&lt;&#39;h, &#39;s&gt;">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.split_once_str" class="fn">split_once_str</a>&lt;'a, B: ?<a class="trait" href="https://doc.rust-lang.org/1.74.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;&gt;(
        &amp;'a self,
        splitter: <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.reference.html">&amp;B</a>
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(&amp;'a [<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>], &amp;'a [<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>])&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.rsplit_once_str" class="fn">rsplit_once_str</a>&lt;'a, B: ?<a class="trait" href="https://doc.rust-lang.org/1.74.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;&gt;(
        &amp;'a self,
        splitter: <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.reference.html">&amp;B</a>
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(&amp;'a [<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>], &amp;'a [<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>])&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.splitn_str" class="fn">splitn_str</a>&lt;'h, 's, B: ?<a class="trait" href="https://doc.rust-lang.org/1.74.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;&gt;(
        &amp;'h self,
        limit: <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a>,
        splitter: <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.reference.html">&amp;'s B</a>
    ) -&gt; <a class="struct" href="struct.SplitN.html" title="struct bstr::SplitN">SplitN</a>&lt;'h, 's&gt; <a href="#" class="tooltip" data-notable-ty="SplitN&lt;&#39;h, &#39;s&gt;">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.rsplitn_str" class="fn">rsplitn_str</a>&lt;'h, 's, B: ?<a class="trait" href="https://doc.rust-lang.org/1.74.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;&gt;(
        &amp;'h self,
        limit: <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a>,
        splitter: <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.reference.html">&amp;'s B</a>
    ) -&gt; <a class="struct" href="struct.SplitNReverse.html" title="struct bstr::SplitNReverse">SplitNReverse</a>&lt;'h, 's&gt; <a href="#" class="tooltip" data-notable-ty="SplitNReverse&lt;&#39;h, &#39;s&gt;">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.replace" class="fn">replace</a>&lt;N: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;, R: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;&gt;(
        &amp;self,
        needle: N,
        replacement: R
    ) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.74.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>&gt; <a href="#" class="tooltip" data-notable-ty="Vec&lt;u8&gt;">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.replacen" class="fn">replacen</a>&lt;N: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;, R: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;&gt;(
        &amp;self,
        needle: N,
        replacement: R,
        limit: <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a>
    ) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.74.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>&gt; <a href="#" class="tooltip" data-notable-ty="Vec&lt;u8&gt;">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.replace_into" class="fn">replace_into</a>&lt;N: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;, R: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;&gt;(
        &amp;self,
        needle: N,
        replacement: R,
        dest: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.74.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>&gt;
    ) { ... }
<span class="item-spacer"></span>    fn <a href="#method.replacen_into" class="fn">replacen_into</a>&lt;N: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;, R: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;&gt;(
        &amp;self,
        needle: N,
        replacement: R,
        limit: <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a>,
        dest: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.74.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>&gt;
    ) { ... }
<span class="item-spacer"></span>    fn <a href="#method.bytes" class="fn">bytes</a>(&amp;self) -&gt; <a class="struct" href="struct.Bytes.html" title="struct bstr::Bytes">Bytes</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="Bytes&lt;&#39;_&gt;">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.chars" class="fn">chars</a>(&amp;self) -&gt; <a class="struct" href="struct.Chars.html" title="struct bstr::Chars">Chars</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="Chars&lt;&#39;_&gt;">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.char_indices" class="fn">char_indices</a>(&amp;self) -&gt; <a class="struct" href="struct.CharIndices.html" title="struct bstr::CharIndices">CharIndices</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="CharIndices&lt;&#39;_&gt;">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.utf8_chunks" class="fn">utf8_chunks</a>(&amp;self) -&gt; <a class="struct" href="struct.Utf8Chunks.html" title="struct bstr::Utf8Chunks">Utf8Chunks</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="Utf8Chunks&lt;&#39;_&gt;">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.lines" class="fn">lines</a>(&amp;self) -&gt; <a class="struct" href="struct.Lines.html" title="struct bstr::Lines">Lines</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="Lines&lt;&#39;_&gt;">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.lines_with_terminator" class="fn">lines_with_terminator</a>(&amp;self) -&gt; <a class="struct" href="struct.LinesWithTerminator.html" title="struct bstr::LinesWithTerminator">LinesWithTerminator</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="LinesWithTerminator&lt;&#39;_&gt;">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.trim_with" class="fn">trim_with</a>&lt;F: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html">char</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.bool.html">bool</a>&gt;(&amp;self, trim: F) -&gt; &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;[u8]">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.trim_start_with" class="fn">trim_start_with</a>&lt;F: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html">char</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.bool.html">bool</a>&gt;(&amp;self, trim: F) -&gt; &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;[u8]">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.trim_end_with" class="fn">trim_end_with</a>&lt;F: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html">char</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.bool.html">bool</a>&gt;(&amp;self, trim: F) -&gt; &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;[u8]">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.to_ascii_lowercase" class="fn">to_ascii_lowercase</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.74.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>&gt; <a href="#" class="tooltip" data-notable-ty="Vec&lt;u8&gt;">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.make_ascii_lowercase" class="fn">make_ascii_lowercase</a>(&amp;mut self) { ... }
<span class="item-spacer"></span>    fn <a href="#method.to_ascii_uppercase" class="fn">to_ascii_uppercase</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.74.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>&gt; <a href="#" class="tooltip" data-notable-ty="Vec&lt;u8&gt;">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.make_ascii_uppercase" class="fn">make_ascii_uppercase</a>(&amp;mut self) { ... }
<span class="item-spacer"></span>    fn <a href="#method.escape_bytes" class="fn">escape_bytes</a>(&amp;self) -&gt; <a class="struct" href="struct.EscapeBytes.html" title="struct bstr::EscapeBytes">EscapeBytes</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="EscapeBytes&lt;&#39;_&gt;">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.reverse_bytes" class="fn">reverse_bytes</a>(&amp;mut self) { ... }
<span class="item-spacer"></span>    fn <a href="#method.reverse_chars" class="fn">reverse_chars</a>(&amp;mut self) { ... }
<span class="item-spacer"></span>    fn <a href="#method.is_ascii" class="fn">is_ascii</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.bool.html">bool</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.is_utf8" class="fn">is_utf8</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.bool.html">bool</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.last_byte" class="fn">last_byte</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.find_non_ascii_byte" class="fn">find_non_ascii_byte</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a>&gt; { ... }
</details>}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A trait that extends <code>&amp;[u8]</code> with string oriented methods.</p>
<p>This trait is sealed and cannot be implemented outside of <code>bstr</code>.</p>
</div></details><h2 id="provided-methods" class="small-section-header">Provided Methods<a href="#provided-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="method.as_bstr" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#145-147">source</a><h4 class="code-header">fn <a href="#method.as_bstr" class="fn">as_bstr</a>(&amp;self) -&gt; &amp;<a class="struct" href="struct.BStr.html" title="struct bstr::BStr">BStr</a></h4></section></summary><div class="docblock"><p>Return this byte slice as a <code>&amp;BStr</code>.</p>
<p>Use <code>&amp;BStr</code> is useful because of its <code>fmt::Debug</code> representation
and various other trait implementations (such as <code>PartialEq</code> and
<code>PartialOrd</code>). In particular, the <code>Debug</code> implementation for <code>BStr</code>
shows its bytes as a normal string. For invalid UTF-8, hex escape
sequences are used.</p>
<h5 id="examples"><a href="#examples">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="string">b&quot;foo\xFFbar&quot;</span>.as_bstr());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_bstr_mut" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#168-170">source</a><h4 class="code-header">fn <a href="#method.as_bstr_mut" class="fn">as_bstr_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="struct.BStr.html" title="struct bstr::BStr">BStr</a></h4></section></summary><div class="docblock"><p>Return this byte slice as a <code>&amp;mut BStr</code>.</p>
<p>Use <code>&amp;mut BStr</code> is useful because of its <code>fmt::Debug</code> representation
and various other trait implementations (such as <code>PartialEq</code> and
<code>PartialOrd</code>). In particular, the <code>Debug</code> implementation for <code>BStr</code>
shows its bytes as a normal string. For invalid UTF-8, hex escape
sequences are used.</p>
<h5 id="examples-1"><a href="#examples-1">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span><span class="kw-2">mut </span>bytes = <span class="kw-2">*</span><span class="string">b&quot;foo\xFFbar&quot;</span>;
<span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="kw-2">&amp;mut </span>bytes.as_bstr_mut());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_os_str" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#196-212">source</a><h4 class="code-header">fn <a href="#method.from_os_str" class="fn">from_os_str</a>(os_str: &amp;<a class="struct" href="https://doc.rust-lang.org/1.74.1/std/ffi/os_str/struct.OsStr.html" title="struct std::ffi::os_str::OsStr">OsStr</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;</h4></section></summary><div class="docblock"><p>Create an immutable byte string from an OS string slice.</p>
<p>When the underlying bytes of OS strings are accessible, then this
always succeeds and is zero cost. Otherwise, this returns <code>None</code> if the
given OS string is not valid UTF-8. (For example, when the underlying
bytes are inaccessible on Windows, file paths are allowed to be a
sequence of arbitrary 16-bit integers. Not all such sequences can be
transcoded to valid UTF-8.)</p>
<h5 id="examples-2"><a href="#examples-2">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::ffi::OsStr;

<span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>os_str = OsStr::new(<span class="string">&quot;foo&quot;</span>);
<span class="kw">let </span>bs = &lt;[u8]&gt;::from_os_str(os_str).expect(<span class="string">&quot;should be valid UTF-8&quot;</span>);
<span class="macro">assert_eq!</span>(bs, B(<span class="string">&quot;foo&quot;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_path" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#238-240">source</a><h4 class="code-header">fn <a href="#method.from_path" class="fn">from_path</a>(path: &amp;<a class="struct" href="https://doc.rust-lang.org/1.74.1/std/path/struct.Path.html" title="struct std::path::Path">Path</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;</h4></section></summary><div class="docblock"><p>Create an immutable byte string from a file path.</p>
<p>When the underlying bytes of paths are accessible, then this always
succeeds and is zero cost. Otherwise, this returns <code>None</code> if the given
path is not valid UTF-8. (For example, when the underlying bytes are
inaccessible on Windows, file paths are allowed to be a sequence of
arbitrary 16-bit integers. Not all such sequences can be transcoded to
valid UTF-8.)</p>
<h5 id="examples-3"><a href="#examples-3">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::path::Path;

<span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>path = Path::new(<span class="string">&quot;foo&quot;</span>);
<span class="kw">let </span>bs = &lt;[u8]&gt;::from_path(path).expect(<span class="string">&quot;should be valid UTF-8&quot;</span>);
<span class="macro">assert_eq!</span>(bs, B(<span class="string">&quot;foo&quot;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_str" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#273-279">source</a><h4 class="code-header">fn <a href="#method.to_str" class="fn">to_str</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;&amp;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html">str</a>, <a class="struct" href="struct.Utf8Error.html" title="struct bstr::Utf8Error">Utf8Error</a>&gt;</h4></section></summary><div class="docblock"><p>Safely convert this byte string into a <code>&amp;str</code> if it’s valid UTF-8.</p>
<p>If this byte string is not valid UTF-8, then an error is returned. The
error returned indicates the first invalid byte found and the length
of the error.</p>
<p>In cases where a lossy conversion to <code>&amp;str</code> is acceptable, then use one
of the <a href="trait.ByteSlice.html#method.to_str_lossy"><code>to_str_lossy</code></a> or
<a href="trait.ByteSlice.html#method.to_str_lossy_into"><code>to_str_lossy_into</code></a>
methods.</p>
<h5 id="examples-4"><a href="#examples-4">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice, ByteVec};

<span class="kw">let </span>s = B(<span class="string">&quot;☃βツ&quot;</span>).to_str()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="string">&quot;☃βツ&quot;</span>, s);

<span class="kw">let </span><span class="kw-2">mut </span>bstring = &lt;Vec&lt;u8&gt;&gt;::from(<span class="string">&quot;☃βツ&quot;</span>);
bstring.push(<span class="string">b&#39;\xFF&#39;</span>);
<span class="kw">let </span>err = bstring.to_str().unwrap_err();
<span class="macro">assert_eq!</span>(<span class="number">8</span>, err.valid_up_to());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_str_unchecked" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#308-310">source</a><h4 class="code-header">unsafe fn <a href="#method.to_str_unchecked" class="fn">to_str_unchecked</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html">str</a></h4></section></summary><div class="docblock"><p>Unsafely convert this byte string into a <code>&amp;str</code>, without checking for
valid UTF-8.</p>
<h5 id="safety"><a href="#safety">Safety</a></h5>
<p>Callers <em>must</em> ensure that this byte string is valid UTF-8 before
calling this method. Converting a byte string into a <code>&amp;str</code> that is
not valid UTF-8 is considered undefined behavior.</p>
<p>This routine is useful in performance sensitive contexts where the
UTF-8 validity of the byte string is already known and it is
undesirable to pay the cost of an additional UTF-8 validation check
that <a href="trait.ByteSlice.html#method.to_str"><code>to_str</code></a> performs.</p>
<h5 id="examples-5"><a href="#examples-5">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="comment">// SAFETY: This is safe because string literals are guaranteed to be
// valid UTF-8 by the Rust compiler.
</span><span class="kw">let </span>s = <span class="kw">unsafe </span>{ B(<span class="string">&quot;☃βツ&quot;</span>).to_str_unchecked() };
<span class="macro">assert_eq!</span>(<span class="string">&quot;☃βツ&quot;</span>, s);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_str_lossy" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#373-396">source</a><h4 class="code-header">fn <a href="#method.to_str_lossy" class="fn">to_str_lossy</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/alloc/borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;'_, <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html">str</a>&gt;</h4></section></summary><div class="docblock"><p>Convert this byte string to a valid UTF-8 string by replacing invalid
UTF-8 bytes with the Unicode replacement codepoint (<code>U+FFFD</code>).</p>
<p>If the byte string is already valid UTF-8, then no copying or
allocation is performed and a borrrowed string slice is returned. If
the byte string is not valid UTF-8, then an owned string buffer is
returned with invalid bytes replaced by the replacement codepoint.</p>
<p>This method uses the “substitution of maximal subparts” (Unicode
Standard, Chapter 3, Section 9) strategy for inserting the replacement
codepoint. Specifically, a replacement codepoint is inserted whenever a
byte is found that cannot possibly lead to a valid code unit sequence.
If there were previous bytes that represented a prefix of a well-formed
code unit sequence, then all of those bytes are substituted with a
single replacement codepoint. The “substitution of maximal subparts”
strategy is the same strategy used by
<a href="https://www.w3.org/TR/encoding/">W3C’s Encoding standard</a>.
For a more precise description of the maximal subpart strategy, see
the Unicode Standard, Chapter 3, Section 9. See also
<a href="https://www.unicode.org/review/pr-121.html">Public Review Issue #121</a>.</p>
<p>N.B. Rust’s standard library also appears to use the same strategy,
but it does not appear to be an API guarantee.</p>
<h5 id="examples-6"><a href="#examples-6">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::borrow::Cow;

<span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span><span class="kw-2">mut </span>bstring = &lt;Vec&lt;u8&gt;&gt;::from(<span class="string">&quot;☃βツ&quot;</span>);
<span class="macro">assert_eq!</span>(Cow::Borrowed(<span class="string">&quot;☃βツ&quot;</span>), bstring.to_str_lossy());

<span class="comment">// Add a byte that makes the sequence invalid.
</span>bstring.push(<span class="string">b&#39;\xFF&#39;</span>);
<span class="macro">assert_eq!</span>(Cow::Borrowed(<span class="string">&quot;☃βツ\u{FFFD}&quot;</span>), bstring.to_str_lossy());</code></pre></div>
<p>This demonstrates the “maximal subpart” substitution logic.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="comment">// \x61 is the ASCII codepoint for &#39;a&#39;.
// \xF1\x80\x80 is a valid 3-byte code unit prefix.
// \xE1\x80 is a valid 2-byte code unit prefix.
// \xC2 is a valid 1-byte code unit prefix.
// \x62 is the ASCII codepoint for &#39;b&#39;.
//
// In sum, each of the prefixes is replaced by a single replacement
// codepoint since none of the prefixes are properly completed. This
// is in contrast to other strategies that might insert a replacement
// codepoint for every single byte.
</span><span class="kw">let </span>bs = B(<span class="string">b&quot;\x61\xF1\x80\x80\xE1\x80\xC2\x62&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;a\u{FFFD}\u{FFFD}\u{FFFD}b&quot;</span>, bs.to_str_lossy());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_str_lossy_into" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#430-454">source</a><h4 class="code-header">fn <a href="#method.to_str_lossy_into" class="fn">to_str_lossy_into</a>(&amp;self, dest: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.74.1/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>)</h4></section></summary><div class="docblock"><p>Copy the contents of this byte string into the given owned string
buffer, while replacing invalid UTF-8 code unit sequences with the
Unicode replacement codepoint (<code>U+FFFD</code>).</p>
<p>This method uses the same “substitution of maximal subparts” strategy
for inserting the replacement codepoint as the
<a href="trait.ByteSlice.html#method.to_str_lossy"><code>to_str_lossy</code></a> method.</p>
<p>This routine is useful for amortizing allocation. However, unlike
<code>to_str_lossy</code>, this routine will <em>always</em> copy the contents of this
byte string into the destination buffer, even if this byte string is
valid UTF-8.</p>
<h5 id="examples-7"><a href="#examples-7">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::borrow::Cow;

<span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span><span class="kw-2">mut </span>bstring = &lt;Vec&lt;u8&gt;&gt;::from(<span class="string">&quot;☃βツ&quot;</span>);
<span class="comment">// Add a byte that makes the sequence invalid.
</span>bstring.push(<span class="string">b&#39;\xFF&#39;</span>);

<span class="kw">let </span><span class="kw-2">mut </span>dest = String::new();
bstring.to_str_lossy_into(<span class="kw-2">&amp;mut </span>dest);
<span class="macro">assert_eq!</span>(<span class="string">&quot;☃βツ\u{FFFD}&quot;</span>, dest);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_os_str" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#480-496">source</a><h4 class="code-header">fn <a href="#method.to_os_str" class="fn">to_os_str</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;&amp;<a class="struct" href="https://doc.rust-lang.org/1.74.1/std/ffi/os_str/struct.OsStr.html" title="struct std::ffi::os_str::OsStr">OsStr</a>, <a class="struct" href="struct.Utf8Error.html" title="struct bstr::Utf8Error">Utf8Error</a>&gt;</h4></section></summary><div class="docblock"><p>Create an OS string slice from this byte string.</p>
<p>When OS strings can be constructed from arbitrary byte sequences, this
always succeeds and is zero cost. Otherwise, this returns a UTF-8
decoding error if this byte string is not valid UTF-8. (For example,
assuming the representation of <code>OsStr</code> is opaque on Windows, file paths
are allowed to be a sequence of arbitrary 16-bit integers. There is
no obvious mapping from an arbitrary sequence of 8-bit integers to an
arbitrary sequence of 16-bit integers. If the representation of <code>OsStr</code>
is even opened up, then this will convert any sequence of bytes to an
<code>OsStr</code> without cost.)</p>
<h5 id="examples-8"><a href="#examples-8">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>os_str = <span class="string">b&quot;foo&quot;</span>.to_os_str().expect(<span class="string">&quot;should be valid UTF-8&quot;</span>);
<span class="macro">assert_eq!</span>(os_str, <span class="string">&quot;foo&quot;</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_os_str_lossy" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#520-541">source</a><h4 class="code-header">fn <a href="#method.to_os_str_lossy" class="fn">to_os_str_lossy</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/alloc/borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;'_, <a class="struct" href="https://doc.rust-lang.org/1.74.1/std/ffi/os_str/struct.OsStr.html" title="struct std::ffi::os_str::OsStr">OsStr</a>&gt;</h4></section></summary><div class="docblock"><p>Lossily create an OS string slice from this byte string.</p>
<p>When OS strings can be constructed from arbitrary byte sequences, this
is zero cost and always returns a slice. Otherwise, this will perform a
UTF-8 check and lossily convert this byte string into valid UTF-8 using
the Unicode replacement codepoint.</p>
<p>Note that this can prevent the correct roundtripping of file paths when
the representation of <code>OsStr</code> is opaque.</p>
<h5 id="examples-9"><a href="#examples-9">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>os_str = <span class="string">b&quot;foo\xFFbar&quot;</span>.to_os_str_lossy();
<span class="macro">assert_eq!</span>(os_str.to_string_lossy(), <span class="string">&quot;foo\u{FFFD}bar&quot;</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_path" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#567-569">source</a><h4 class="code-header">fn <a href="#method.to_path" class="fn">to_path</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;&amp;<a class="struct" href="https://doc.rust-lang.org/1.74.1/std/path/struct.Path.html" title="struct std::path::Path">Path</a>, <a class="struct" href="struct.Utf8Error.html" title="struct bstr::Utf8Error">Utf8Error</a>&gt;</h4></section></summary><div class="docblock"><p>Create a path slice from this byte string.</p>
<p>When paths can be constructed from arbitrary byte sequences, this
always succeeds and is zero cost. Otherwise, this returns a UTF-8
decoding error if this byte string is not valid UTF-8. (For example,
assuming the representation of <code>Path</code> is opaque on Windows, file paths
are allowed to be a sequence of arbitrary 16-bit integers. There is
no obvious mapping from an arbitrary sequence of 8-bit integers to an
arbitrary sequence of 16-bit integers. If the representation of <code>Path</code>
is even opened up, then this will convert any sequence of bytes to an
<code>Path</code> without cost.)</p>
<h5 id="examples-10"><a href="#examples-10">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>path = <span class="string">b&quot;foo&quot;</span>.to_path().expect(<span class="string">&quot;should be valid UTF-8&quot;</span>);
<span class="macro">assert_eq!</span>(path.as_os_str(), <span class="string">&quot;foo&quot;</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_path_lossy" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#594-601">source</a><h4 class="code-header">fn <a href="#method.to_path_lossy" class="fn">to_path_lossy</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/alloc/borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;'_, <a class="struct" href="https://doc.rust-lang.org/1.74.1/std/path/struct.Path.html" title="struct std::path::Path">Path</a>&gt;</h4></section></summary><div class="docblock"><p>Lossily create a path slice from this byte string.</p>
<p>When paths can be constructed from arbitrary byte sequences, this is
zero cost and always returns a slice. Otherwise, this will perform a
UTF-8 check and lossily convert this byte string into valid UTF-8 using
the Unicode replacement codepoint.</p>
<p>Note that this can prevent the correct roundtripping of file paths when
the representation of <code>Path</code> is opaque.</p>
<h5 id="examples-11"><a href="#examples-11">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>bs = <span class="string">b&quot;foo\xFFbar&quot;</span>;
<span class="kw">let </span>path = bs.to_path_lossy();
<span class="macro">assert_eq!</span>(path.to_string_lossy(), <span class="string">&quot;foo\u{FFFD}bar&quot;</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.repeatn" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#622-624">source</a><h4 class="code-header">fn <a href="#method.repeatn" class="fn">repeatn</a>(&amp;self, n: <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.74.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>&gt; <a href="#" class="tooltip" data-notable-ty="Vec&lt;u8&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Create a new byte string by repeating this byte string <code>n</code> times.</p>
<h5 id="panics"><a href="#panics">Panics</a></h5>
<p>This function panics if the capacity of the new byte string would
overflow.</p>
<h5 id="examples-12"><a href="#examples-12">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="macro">assert_eq!</span>(<span class="string">b&quot;foo&quot;</span>.repeatn(<span class="number">4</span>), B(<span class="string">&quot;foofoofoofoo&quot;</span>));
<span class="macro">assert_eq!</span>(<span class="string">b&quot;foo&quot;</span>.repeatn(<span class="number">0</span>), B(<span class="string">&quot;&quot;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.contains_str" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#640-642">source</a><h4 class="code-header">fn <a href="#method.contains_str" class="fn">contains_str</a>&lt;B: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;&gt;(&amp;self, needle: B) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if this byte string contains the given needle.</p>
<h5 id="examples-13"><a href="#examples-13">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="macro">assert!</span>(<span class="string">b&quot;foo bar&quot;</span>.contains_str(<span class="string">&quot;foo&quot;</span>));
<span class="macro">assert!</span>(<span class="string">b&quot;foo bar&quot;</span>.contains_str(<span class="string">&quot;bar&quot;</span>));
<span class="macro">assert!</span>(!<span class="string">b&quot;foo&quot;</span>.contains_str(<span class="string">&quot;foobar&quot;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.starts_with_str" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#658-660">source</a><h4 class="code-header">fn <a href="#method.starts_with_str" class="fn">starts_with_str</a>&lt;B: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;&gt;(&amp;self, prefix: B) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if this byte string has the given prefix.</p>
<h5 id="examples-14"><a href="#examples-14">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="macro">assert!</span>(<span class="string">b&quot;foo bar&quot;</span>.starts_with_str(<span class="string">&quot;foo&quot;</span>));
<span class="macro">assert!</span>(!<span class="string">b&quot;foo bar&quot;</span>.starts_with_str(<span class="string">&quot;bar&quot;</span>));
<span class="macro">assert!</span>(!<span class="string">b&quot;foo&quot;</span>.starts_with_str(<span class="string">&quot;foobar&quot;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.ends_with_str" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#676-678">source</a><h4 class="code-header">fn <a href="#method.ends_with_str" class="fn">ends_with_str</a>&lt;B: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;&gt;(&amp;self, suffix: B) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if this byte string has the given suffix.</p>
<h5 id="examples-15"><a href="#examples-15">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="macro">assert!</span>(<span class="string">b&quot;foo bar&quot;</span>.ends_with_str(<span class="string">&quot;bar&quot;</span>));
<span class="macro">assert!</span>(!<span class="string">b&quot;foo bar&quot;</span>.ends_with_str(<span class="string">&quot;foo&quot;</span>));
<span class="macro">assert!</span>(!<span class="string">b&quot;bar&quot;</span>.ends_with_str(<span class="string">&quot;foobar&quot;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#711-713">source</a><h4 class="code-header">fn <a href="#method.find" class="fn">find</a>&lt;B: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;&gt;(&amp;self, needle: B) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the index of the first occurrence of the given needle.</p>
<p>The needle may be any type that can be cheaply converted into a
<code>&amp;[u8]</code>. This includes, but is not limited to, <code>&amp;str</code> and <code>&amp;[u8]</code>.</p>
<p>Note that if you’re are searching for the same needle in many
different small haystacks, it may be faster to initialize a
<a href="struct.Finder.html"><code>Finder</code></a> once, and reuse it for each search.</p>
<h5 id="complexity"><a href="#complexity">Complexity</a></h5>
<p>This routine is guaranteed to have worst case linear time complexity
with respect to both the needle and the haystack. That is, this runs
in <code>O(needle.len() + haystack.len())</code> time.</p>
<p>This routine is also guaranteed to have worst case constant space
complexity.</p>
<h5 id="examples-16"><a href="#examples-16">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>s = <span class="string">b&quot;foo bar baz&quot;</span>;
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">0</span>), s.find(<span class="string">&quot;foo&quot;</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">4</span>), s.find(<span class="string">&quot;bar&quot;</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, s.find(<span class="string">&quot;quux&quot;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rfind" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#748-750">source</a><h4 class="code-header">fn <a href="#method.rfind" class="fn">rfind</a>&lt;B: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;&gt;(&amp;self, needle: B) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the index of the last occurrence of the given needle.</p>
<p>The needle may be any type that can be cheaply converted into a
<code>&amp;[u8]</code>. This includes, but is not limited to, <code>&amp;str</code> and <code>&amp;[u8]</code>.</p>
<p>Note that if you’re are searching for the same needle in many
different small haystacks, it may be faster to initialize a
<a href="struct.FinderReverse.html"><code>FinderReverse</code></a> once, and reuse it for
each search.</p>
<h5 id="complexity-1"><a href="#complexity-1">Complexity</a></h5>
<p>This routine is guaranteed to have worst case linear time complexity
with respect to both the needle and the haystack. That is, this runs
in <code>O(needle.len() + haystack.len())</code> time.</p>
<p>This routine is also guaranteed to have worst case constant space
complexity.</p>
<h5 id="examples-17"><a href="#examples-17">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>s = <span class="string">b&quot;foo bar baz&quot;</span>;
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">0</span>), s.rfind(<span class="string">&quot;foo&quot;</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">4</span>), s.rfind(<span class="string">&quot;bar&quot;</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">8</span>), s.rfind(<span class="string">&quot;ba&quot;</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, s.rfind(<span class="string">&quot;quux&quot;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_iter" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#790-795">source</a><h4 class="code-header">fn <a href="#method.find_iter" class="fn">find_iter</a>&lt;'h, 'n, B: ?<a class="trait" href="https://doc.rust-lang.org/1.74.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;&gt;(
    &amp;'h self,
    needle: <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.reference.html">&amp;'n B</a>
) -&gt; <a class="struct" href="struct.Find.html" title="struct bstr::Find">Find</a>&lt;'h, 'n&gt; <a href="#" class="tooltip" data-notable-ty="Find&lt;&#39;h, &#39;n&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator of the non-overlapping occurrences of the given
needle. The iterator yields byte offset positions indicating the start
of each match.</p>
<h5 id="complexity-2"><a href="#complexity-2">Complexity</a></h5>
<p>This routine is guaranteed to have worst case linear time complexity
with respect to both the needle and the haystack. That is, this runs
in <code>O(needle.len() + haystack.len())</code> time.</p>
<p>This routine is also guaranteed to have worst case constant space
complexity.</p>
<h5 id="examples-18"><a href="#examples-18">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>s = <span class="string">b&quot;foo bar foo foo quux foo&quot;</span>;
<span class="kw">let </span>matches: Vec&lt;usize&gt; = s.find_iter(<span class="string">&quot;foo&quot;</span>).collect();
<span class="macro">assert_eq!</span>(matches, <span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">21</span>]);</code></pre></div>
<p>An empty string matches at every position, including the position
immediately following the last byte:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>matches: Vec&lt;usize&gt; = <span class="string">b&quot;foo&quot;</span>.find_iter(<span class="string">&quot;&quot;</span>).collect();
<span class="macro">assert_eq!</span>(matches, <span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);

<span class="kw">let </span>matches: Vec&lt;usize&gt; = <span class="string">b&quot;&quot;</span>.find_iter(<span class="string">&quot;&quot;</span>).collect();
<span class="macro">assert_eq!</span>(matches, <span class="macro">vec!</span>[<span class="number">0</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rfind_iter" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#835-840">source</a><h4 class="code-header">fn <a href="#method.rfind_iter" class="fn">rfind_iter</a>&lt;'h, 'n, B: ?<a class="trait" href="https://doc.rust-lang.org/1.74.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;&gt;(
    &amp;'h self,
    needle: <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.reference.html">&amp;'n B</a>
) -&gt; <a class="struct" href="struct.FindReverse.html" title="struct bstr::FindReverse">FindReverse</a>&lt;'h, 'n&gt; <a href="#" class="tooltip" data-notable-ty="FindReverse&lt;&#39;h, &#39;n&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator of the non-overlapping occurrences of the given
needle in reverse. The iterator yields byte offset positions indicating
the start of each match.</p>
<h5 id="complexity-3"><a href="#complexity-3">Complexity</a></h5>
<p>This routine is guaranteed to have worst case linear time complexity
with respect to both the needle and the haystack. That is, this runs
in <code>O(needle.len() + haystack.len())</code> time.</p>
<p>This routine is also guaranteed to have worst case constant space
complexity.</p>
<h5 id="examples-19"><a href="#examples-19">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>s = <span class="string">b&quot;foo bar foo foo quux foo&quot;</span>;
<span class="kw">let </span>matches: Vec&lt;usize&gt; = s.rfind_iter(<span class="string">&quot;foo&quot;</span>).collect();
<span class="macro">assert_eq!</span>(matches, <span class="macro">vec!</span>[<span class="number">21</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">0</span>]);</code></pre></div>
<p>An empty string matches at every position, including the position
immediately following the last byte:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>matches: Vec&lt;usize&gt; = <span class="string">b&quot;foo&quot;</span>.rfind_iter(<span class="string">&quot;&quot;</span>).collect();
<span class="macro">assert_eq!</span>(matches, <span class="macro">vec!</span>[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]);

<span class="kw">let </span>matches: Vec&lt;usize&gt; = <span class="string">b&quot;&quot;</span>.rfind_iter(<span class="string">&quot;&quot;</span>).collect();
<span class="macro">assert_eq!</span>(matches, <span class="macro">vec!</span>[<span class="number">0</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_byte" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#856-858">source</a><h4 class="code-header">fn <a href="#method.find_byte" class="fn">find_byte</a>(&amp;self, byte: <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the index of the first occurrence of the given byte. If the
byte does not occur in this byte string, then <code>None</code> is returned.</p>
<h5 id="examples-20"><a href="#examples-20">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">10</span>), <span class="string">b&quot;foo bar baz&quot;</span>.find_byte(<span class="string">b&#39;z&#39;</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="string">b&quot;foo bar baz&quot;</span>.find_byte(<span class="string">b&#39;y&#39;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rfind_byte" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#874-876">source</a><h4 class="code-header">fn <a href="#method.rfind_byte" class="fn">rfind_byte</a>(&amp;self, byte: <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the index of the last occurrence of the given byte. If the
byte does not occur in this byte string, then <code>None</code> is returned.</p>
<h5 id="examples-21"><a href="#examples-21">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">10</span>), <span class="string">b&quot;foo bar baz&quot;</span>.rfind_byte(<span class="string">b&#39;z&#39;</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="string">b&quot;foo bar baz&quot;</span>.rfind_byte(<span class="string">b&#39;y&#39;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_char" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#898-900">source</a><h4 class="code-header">fn <a href="#method.find_char" class="fn">find_char</a>(&amp;self, ch: <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html">char</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the index of the first occurrence of the given codepoint.
If the codepoint does not occur in this byte string, then <code>None</code> is
returned.</p>
<p>Note that if one searches for the replacement codepoint, <code>\u{FFFD}</code>,
then only explicit occurrences of that encoding will be found. Invalid
UTF-8 sequences will not be matched.</p>
<h5 id="examples-22"><a href="#examples-22">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">10</span>), <span class="string">b&quot;foo bar baz&quot;</span>.find_char(<span class="string">&#39;z&#39;</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">4</span>), B(<span class="string">&quot;αβγγδ&quot;</span>).find_char(<span class="string">&#39;γ&#39;</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="string">b&quot;foo bar baz&quot;</span>.find_char(<span class="string">&#39;y&#39;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rfind_char" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#922-924">source</a><h4 class="code-header">fn <a href="#method.rfind_char" class="fn">rfind_char</a>(&amp;self, ch: <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html">char</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the index of the last occurrence of the given codepoint.
If the codepoint does not occur in this byte string, then <code>None</code> is
returned.</p>
<p>Note that if one searches for the replacement codepoint, <code>\u{FFFD}</code>,
then only explicit occurrences of that encoding will be found. Invalid
UTF-8 sequences will not be matched.</p>
<h5 id="examples-23"><a href="#examples-23">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">10</span>), <span class="string">b&quot;foo bar baz&quot;</span>.rfind_char(<span class="string">&#39;z&#39;</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">6</span>), B(<span class="string">&quot;αβγγδ&quot;</span>).rfind_char(<span class="string">&#39;γ&#39;</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="string">b&quot;foo bar baz&quot;</span>.rfind_char(<span class="string">&#39;y&#39;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_byteset" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#962-964">source</a><h4 class="code-header">fn <a href="#method.find_byteset" class="fn">find_byteset</a>&lt;B: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;&gt;(&amp;self, byteset: B) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the index of the first occurrence of any of the bytes in the
provided set.</p>
<p>The <code>byteset</code> may be any type that can be cheaply converted into a
<code>&amp;[u8]</code>. This includes, but is not limited to, <code>&amp;str</code> and <code>&amp;[u8]</code>, but
note that passing a <code>&amp;str</code> which contains multibyte characters may not
behave as you expect: each byte in the <code>&amp;str</code> is treated as an
individual member of the byte set.</p>
<p>Note that order is irrelevant for the <code>byteset</code> parameter, and
duplicate bytes present in its body are ignored.</p>
<h5 id="complexity-4"><a href="#complexity-4">Complexity</a></h5>
<p>This routine is guaranteed to have worst case linear time complexity
with respect to both the set of bytes and the haystack. That is, this
runs in <code>O(byteset.len() + haystack.len())</code> time.</p>
<p>This routine is also guaranteed to have worst case constant space
complexity.</p>
<h5 id="examples-24"><a href="#examples-24">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="macro">assert_eq!</span>(<span class="string">b&quot;foo bar baz&quot;</span>.find_byteset(<span class="string">b&quot;zr&quot;</span>), <span class="prelude-val">Some</span>(<span class="number">6</span>));
<span class="macro">assert_eq!</span>(<span class="string">b&quot;foo baz bar&quot;</span>.find_byteset(<span class="string">b&quot;bzr&quot;</span>), <span class="prelude-val">Some</span>(<span class="number">4</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="string">b&quot;foo baz bar&quot;</span>.find_byteset(<span class="string">b&quot;\t\n&quot;</span>));
<span class="comment">// The empty byteset never matches.
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="string">b&quot;abc&quot;</span>.find_byteset(<span class="string">b&quot;&quot;</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="string">b&quot;&quot;</span>.find_byteset(<span class="string">b&quot;&quot;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_not_byteset" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#1003-1005">source</a><h4 class="code-header">fn <a href="#method.find_not_byteset" class="fn">find_not_byteset</a>&lt;B: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;&gt;(&amp;self, byteset: B) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the index of the first occurrence of a byte that is not a
member of the provided set.</p>
<p>The <code>byteset</code> may be any type that can be cheaply converted into a
<code>&amp;[u8]</code>. This includes, but is not limited to, <code>&amp;str</code> and <code>&amp;[u8]</code>, but
note that passing a <code>&amp;str</code> which contains multibyte characters may not
behave as you expect: each byte in the <code>&amp;str</code> is treated as an
individual member of the byte set.</p>
<p>Note that order is irrelevant for the <code>byteset</code> parameter, and
duplicate bytes present in its body are ignored.</p>
<h5 id="complexity-5"><a href="#complexity-5">Complexity</a></h5>
<p>This routine is guaranteed to have worst case linear time complexity
with respect to both the set of bytes and the haystack. That is, this
runs in <code>O(byteset.len() + haystack.len())</code> time.</p>
<p>This routine is also guaranteed to have worst case constant space
complexity.</p>
<h5 id="examples-25"><a href="#examples-25">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="macro">assert_eq!</span>(<span class="string">b&quot;foo bar baz&quot;</span>.find_not_byteset(<span class="string">b&quot;fo &quot;</span>), <span class="prelude-val">Some</span>(<span class="number">4</span>));
<span class="macro">assert_eq!</span>(<span class="string">b&quot;\t\tbaz bar&quot;</span>.find_not_byteset(<span class="string">b&quot; \t\r\n&quot;</span>), <span class="prelude-val">Some</span>(<span class="number">2</span>));
<span class="macro">assert_eq!</span>(<span class="string">b&quot;foo\nbaz\tbar&quot;</span>.find_not_byteset(<span class="string">b&quot;\t\n&quot;</span>), <span class="prelude-val">Some</span>(<span class="number">0</span>));
<span class="comment">// The negation of the empty byteset matches everything.
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">0</span>), <span class="string">b&quot;abc&quot;</span>.find_not_byteset(<span class="string">b&quot;&quot;</span>));
<span class="comment">// But an empty string never contains anything.
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="string">b&quot;&quot;</span>.find_not_byteset(<span class="string">b&quot;&quot;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rfind_byteset" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#1040-1042">source</a><h4 class="code-header">fn <a href="#method.rfind_byteset" class="fn">rfind_byteset</a>&lt;B: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;&gt;(&amp;self, byteset: B) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the index of the last occurrence of any of the bytes in the
provided set.</p>
<p>The <code>byteset</code> may be any type that can be cheaply converted into a
<code>&amp;[u8]</code>. This includes, but is not limited to, <code>&amp;str</code> and <code>&amp;[u8]</code>, but
note that passing a <code>&amp;str</code> which contains multibyte characters may not
behave as you expect: each byte in the <code>&amp;str</code> is treated as an
individual member of the byte set.</p>
<p>Note that order is irrelevant for the <code>byteset</code> parameter, and duplicate
bytes present in its body are ignored.</p>
<h5 id="complexity-6"><a href="#complexity-6">Complexity</a></h5>
<p>This routine is guaranteed to have worst case linear time complexity
with respect to both the set of bytes and the haystack. That is, this
runs in <code>O(byteset.len() + haystack.len())</code> time.</p>
<p>This routine is also guaranteed to have worst case constant space
complexity.</p>
<h5 id="examples-26"><a href="#examples-26">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="macro">assert_eq!</span>(<span class="string">b&quot;foo bar baz&quot;</span>.rfind_byteset(<span class="string">b&quot;agb&quot;</span>), <span class="prelude-val">Some</span>(<span class="number">9</span>));
<span class="macro">assert_eq!</span>(<span class="string">b&quot;foo baz bar&quot;</span>.rfind_byteset(<span class="string">b&quot;rabz &quot;</span>), <span class="prelude-val">Some</span>(<span class="number">10</span>));
<span class="macro">assert_eq!</span>(<span class="string">b&quot;foo baz bar&quot;</span>.rfind_byteset(<span class="string">b&quot;\n123&quot;</span>), <span class="prelude-val">None</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rfind_not_byteset" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#1077-1079">source</a><h4 class="code-header">fn <a href="#method.rfind_not_byteset" class="fn">rfind_not_byteset</a>&lt;B: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;&gt;(&amp;self, byteset: B) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the index of the last occurrence of a byte that is not a member
of the provided set.</p>
<p>The <code>byteset</code> may be any type that can be cheaply converted into a
<code>&amp;[u8]</code>. This includes, but is not limited to, <code>&amp;str</code> and <code>&amp;[u8]</code>, but
note that passing a <code>&amp;str</code> which contains multibyte characters may not
behave as you expect: each byte in the <code>&amp;str</code> is treated as an
individual member of the byte set.</p>
<p>Note that order is irrelevant for the <code>byteset</code> parameter, and
duplicate bytes present in its body are ignored.</p>
<h5 id="complexity-7"><a href="#complexity-7">Complexity</a></h5>
<p>This routine is guaranteed to have worst case linear time complexity
with respect to both the set of bytes and the haystack. That is, this
runs in <code>O(byteset.len() + haystack.len())</code> time.</p>
<p>This routine is also guaranteed to have worst case constant space
complexity.</p>
<h5 id="examples-27"><a href="#examples-27">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="macro">assert_eq!</span>(<span class="string">b&quot;foo bar baz,\t&quot;</span>.rfind_not_byteset(<span class="string">b&quot;,\t&quot;</span>), <span class="prelude-val">Some</span>(<span class="number">10</span>));
<span class="macro">assert_eq!</span>(<span class="string">b&quot;foo baz bar&quot;</span>.rfind_not_byteset(<span class="string">b&quot;rabz &quot;</span>), <span class="prelude-val">Some</span>(<span class="number">2</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="string">b&quot;foo baz bar&quot;</span>.rfind_not_byteset(<span class="string">b&quot;barfoz &quot;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.fields_with" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#1138-1140">source</a><h4 class="code-header">fn <a href="#method.fields_with" class="fn">fields_with</a>&lt;F: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html">char</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.bool.html">bool</a>&gt;(&amp;self, f: F) -&gt; <a class="struct" href="struct.FieldsWith.html" title="struct bstr::FieldsWith">FieldsWith</a>&lt;'_, F&gt; <a href="#" class="tooltip" data-notable-ty="FieldsWith&lt;&#39;_, F&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator over the fields in a byte string, separated by
contiguous codepoints satisfying the given predicate.</p>
<p>If this byte string is not valid UTF-8, then the given closure will
be called with a Unicode replacement codepoint when invalid UTF-8
bytes are seen.</p>
<h5 id="example"><a href="#example">Example</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>s = <span class="string">b&quot;123foo999999bar1quux123456&quot;</span>;
<span class="kw">let </span>fields: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = s.fields_with(|c| c.is_numeric()).collect();
<span class="macro">assert_eq!</span>(fields, <span class="macro">vec!</span>[B(<span class="string">&quot;foo&quot;</span>), B(<span class="string">&quot;bar&quot;</span>), B(<span class="string">&quot;quux&quot;</span>)]);</code></pre></div>
<p>A byte string consisting of all codepoints satisfying the predicate
yields no elements:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="macro">assert_eq!</span>(<span class="number">0</span>, <span class="string">b&quot;1911354563&quot;</span>.fields_with(|c| c.is_numeric()).count());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_str" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#1231-1236">source</a><h4 class="code-header">fn <a href="#method.split_str" class="fn">split_str</a>&lt;'h, 's, B: ?<a class="trait" href="https://doc.rust-lang.org/1.74.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;&gt;(
    &amp;'h self,
    splitter: <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.reference.html">&amp;'s B</a>
) -&gt; <a class="struct" href="struct.Split.html" title="struct bstr::Split">Split</a>&lt;'h, 's&gt; <a href="#" class="tooltip" data-notable-ty="Split&lt;&#39;h, &#39;s&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator over substrings of this byte string, separated
by the given byte string. Each element yielded is guaranteed not to
include the splitter substring.</p>
<p>The splitter may be any type that can be cheaply converted into a
<code>&amp;[u8]</code>. This includes, but is not limited to, <code>&amp;str</code> and <code>&amp;[u8]</code>.</p>
<h5 id="examples-28"><a href="#examples-28">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>x: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = <span class="string">b&quot;Mary had a little lamb&quot;</span>.split_str(<span class="string">&quot; &quot;</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[
    B(<span class="string">&quot;Mary&quot;</span>), B(<span class="string">&quot;had&quot;</span>), B(<span class="string">&quot;a&quot;</span>), B(<span class="string">&quot;little&quot;</span>), B(<span class="string">&quot;lamb&quot;</span>),
]);

<span class="kw">let </span>x: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = <span class="string">b&quot;&quot;</span>.split_str(<span class="string">&quot;X&quot;</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[<span class="string">b&quot;&quot;</span>]);

<span class="kw">let </span>x: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = <span class="string">b&quot;lionXXtigerXleopard&quot;</span>.split_str(<span class="string">&quot;X&quot;</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[B(<span class="string">&quot;lion&quot;</span>), B(<span class="string">&quot;&quot;</span>), B(<span class="string">&quot;tiger&quot;</span>), B(<span class="string">&quot;leopard&quot;</span>)]);

<span class="kw">let </span>x: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = <span class="string">b&quot;lion::tiger::leopard&quot;</span>.split_str(<span class="string">&quot;::&quot;</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[B(<span class="string">&quot;lion&quot;</span>), B(<span class="string">&quot;tiger&quot;</span>), B(<span class="string">&quot;leopard&quot;</span>)]);</code></pre></div>
<p>If a string contains multiple contiguous separators, you will end up
with empty strings yielded by the iterator:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>x: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = <span class="string">b&quot;||||a||b|c&quot;</span>.split_str(<span class="string">&quot;|&quot;</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[
    B(<span class="string">&quot;&quot;</span>), B(<span class="string">&quot;&quot;</span>), B(<span class="string">&quot;&quot;</span>), B(<span class="string">&quot;&quot;</span>), B(<span class="string">&quot;a&quot;</span>), B(<span class="string">&quot;&quot;</span>), B(<span class="string">&quot;b&quot;</span>), B(<span class="string">&quot;c&quot;</span>),
]);

<span class="kw">let </span>x: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = <span class="string">b&quot;(///)&quot;</span>.split_str(<span class="string">&quot;/&quot;</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[B(<span class="string">&quot;(&quot;</span>), B(<span class="string">&quot;&quot;</span>), B(<span class="string">&quot;&quot;</span>), B(<span class="string">&quot;)&quot;</span>)]);</code></pre></div>
<p>Separators at the start or end of a string are neighbored by empty
strings.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>x: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = <span class="string">b&quot;010&quot;</span>.split_str(<span class="string">&quot;0&quot;</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[B(<span class="string">&quot;&quot;</span>), B(<span class="string">&quot;1&quot;</span>), B(<span class="string">&quot;&quot;</span>)]);</code></pre></div>
<p>When the empty string is used as a separator, it splits every <strong>byte</strong>
in the byte string, along with the beginning and end of the byte
string.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>x: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = <span class="string">b&quot;rust&quot;</span>.split_str(<span class="string">&quot;&quot;</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[
    B(<span class="string">&quot;&quot;</span>), B(<span class="string">&quot;r&quot;</span>), B(<span class="string">&quot;u&quot;</span>), B(<span class="string">&quot;s&quot;</span>), B(<span class="string">&quot;t&quot;</span>), B(<span class="string">&quot;&quot;</span>),
]);

<span class="comment">// Splitting by an empty string is not UTF-8 aware. Elements yielded
// may not be valid UTF-8!
</span><span class="kw">let </span>x: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = B(<span class="string">&quot;☃&quot;</span>).split_str(<span class="string">&quot;&quot;</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[
    B(<span class="string">&quot;&quot;</span>), B(<span class="string">b&quot;\xE2&quot;</span>), B(<span class="string">b&quot;\x98&quot;</span>), B(<span class="string">b&quot;\x83&quot;</span>), B(<span class="string">&quot;&quot;</span>),
]);</code></pre></div>
<p>Contiguous separators, especially whitespace, can lead to possibly
surprising behavior. For example, this code is correct:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>x: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = <span class="string">b&quot;    a  b c&quot;</span>.split_str(<span class="string">&quot; &quot;</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[
    B(<span class="string">&quot;&quot;</span>), B(<span class="string">&quot;&quot;</span>), B(<span class="string">&quot;&quot;</span>), B(<span class="string">&quot;&quot;</span>), B(<span class="string">&quot;a&quot;</span>), B(<span class="string">&quot;&quot;</span>), B(<span class="string">&quot;b&quot;</span>), B(<span class="string">&quot;c&quot;</span>),
]);</code></pre></div>
<p>It does <em>not</em> give you <code>[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code>. For that behavior, use
<a href="#method.fields"><code>fields</code></a> instead.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rsplit_str" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#1325-1330">source</a><h4 class="code-header">fn <a href="#method.rsplit_str" class="fn">rsplit_str</a>&lt;'h, 's, B: ?<a class="trait" href="https://doc.rust-lang.org/1.74.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;&gt;(
    &amp;'h self,
    splitter: <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.reference.html">&amp;'s B</a>
) -&gt; <a class="struct" href="struct.SplitReverse.html" title="struct bstr::SplitReverse">SplitReverse</a>&lt;'h, 's&gt; <a href="#" class="tooltip" data-notable-ty="SplitReverse&lt;&#39;h, &#39;s&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator over substrings of this byte string, separated by
the given byte string, in reverse. Each element yielded is guaranteed
not to include the splitter substring.</p>
<p>The splitter may be any type that can be cheaply converted into a
<code>&amp;[u8]</code>. This includes, but is not limited to, <code>&amp;str</code> and <code>&amp;[u8]</code>.</p>
<h5 id="examples-29"><a href="#examples-29">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>x: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; =
    <span class="string">b&quot;Mary had a little lamb&quot;</span>.rsplit_str(<span class="string">&quot; &quot;</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[
    B(<span class="string">&quot;lamb&quot;</span>), B(<span class="string">&quot;little&quot;</span>), B(<span class="string">&quot;a&quot;</span>), B(<span class="string">&quot;had&quot;</span>), B(<span class="string">&quot;Mary&quot;</span>),
]);

<span class="kw">let </span>x: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = <span class="string">b&quot;&quot;</span>.rsplit_str(<span class="string">&quot;X&quot;</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[<span class="string">b&quot;&quot;</span>]);

<span class="kw">let </span>x: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = <span class="string">b&quot;lionXXtigerXleopard&quot;</span>.rsplit_str(<span class="string">&quot;X&quot;</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[B(<span class="string">&quot;leopard&quot;</span>), B(<span class="string">&quot;tiger&quot;</span>), B(<span class="string">&quot;&quot;</span>), B(<span class="string">&quot;lion&quot;</span>)]);

<span class="kw">let </span>x: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = <span class="string">b&quot;lion::tiger::leopard&quot;</span>.rsplit_str(<span class="string">&quot;::&quot;</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[B(<span class="string">&quot;leopard&quot;</span>), B(<span class="string">&quot;tiger&quot;</span>), B(<span class="string">&quot;lion&quot;</span>)]);</code></pre></div>
<p>If a string contains multiple contiguous separators, you will end up
with empty strings yielded by the iterator:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>x: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = <span class="string">b&quot;||||a||b|c&quot;</span>.rsplit_str(<span class="string">&quot;|&quot;</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[
    B(<span class="string">&quot;c&quot;</span>), B(<span class="string">&quot;b&quot;</span>), B(<span class="string">&quot;&quot;</span>), B(<span class="string">&quot;a&quot;</span>), B(<span class="string">&quot;&quot;</span>), B(<span class="string">&quot;&quot;</span>), B(<span class="string">&quot;&quot;</span>), B(<span class="string">&quot;&quot;</span>),
]);

<span class="kw">let </span>x: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = <span class="string">b&quot;(///)&quot;</span>.rsplit_str(<span class="string">&quot;/&quot;</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[B(<span class="string">&quot;)&quot;</span>), B(<span class="string">&quot;&quot;</span>), B(<span class="string">&quot;&quot;</span>), B(<span class="string">&quot;(&quot;</span>)]);</code></pre></div>
<p>Separators at the start or end of a string are neighbored by empty
strings.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>x: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = <span class="string">b&quot;010&quot;</span>.rsplit_str(<span class="string">&quot;0&quot;</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[B(<span class="string">&quot;&quot;</span>), B(<span class="string">&quot;1&quot;</span>), B(<span class="string">&quot;&quot;</span>)]);</code></pre></div>
<p>When the empty string is used as a separator, it splits every <strong>byte</strong>
in the byte string, along with the beginning and end of the byte
string.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>x: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = <span class="string">b&quot;rust&quot;</span>.rsplit_str(<span class="string">&quot;&quot;</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[
    B(<span class="string">&quot;&quot;</span>), B(<span class="string">&quot;t&quot;</span>), B(<span class="string">&quot;s&quot;</span>), B(<span class="string">&quot;u&quot;</span>), B(<span class="string">&quot;r&quot;</span>), B(<span class="string">&quot;&quot;</span>),
]);

<span class="comment">// Splitting by an empty string is not UTF-8 aware. Elements yielded
// may not be valid UTF-8!
</span><span class="kw">let </span>x: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = B(<span class="string">&quot;☃&quot;</span>).rsplit_str(<span class="string">&quot;&quot;</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[B(<span class="string">&quot;&quot;</span>), B(<span class="string">b&quot;\x83&quot;</span>), B(<span class="string">b&quot;\x98&quot;</span>), B(<span class="string">b&quot;\xE2&quot;</span>), B(<span class="string">&quot;&quot;</span>)]);</code></pre></div>
<p>Contiguous separators, especially whitespace, can lead to possibly
surprising behavior. For example, this code is correct:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>x: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = <span class="string">b&quot;    a  b c&quot;</span>.rsplit_str(<span class="string">&quot; &quot;</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[
    B(<span class="string">&quot;c&quot;</span>), B(<span class="string">&quot;b&quot;</span>), B(<span class="string">&quot;&quot;</span>), B(<span class="string">&quot;a&quot;</span>), B(<span class="string">&quot;&quot;</span>), B(<span class="string">&quot;&quot;</span>), B(<span class="string">&quot;&quot;</span>), B(<span class="string">&quot;&quot;</span>),
]);</code></pre></div>
<p>It does <em>not</em> give you <code>[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_once_str" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#1365-1374">source</a><h4 class="code-header">fn <a href="#method.split_once_str" class="fn">split_once_str</a>&lt;'a, B: ?<a class="trait" href="https://doc.rust-lang.org/1.74.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;&gt;(
    &amp;'a self,
    splitter: <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.reference.html">&amp;B</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(&amp;'a [<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>], &amp;'a [<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>])&gt;</h4></section></summary><div class="docblock"><p>Split this byte string at the first occurrence of <code>splitter</code>.</p>
<p>If the <code>splitter</code> is found in the byte string, returns a tuple
containing the parts of the string before and after the first occurrence
of <code>splitter</code> respectively. Otherwise, if there are no occurrences of
<code>splitter</code> in the byte string, returns <code>None</code>.</p>
<p>The splitter may be any type that can be cheaply converted into a
<code>&amp;[u8]</code>. This includes, but is not limited to, <code>&amp;str</code> and <code>&amp;[u8]</code>.</p>
<p>If you need to split on the <em>last</em> instance of a delimiter instead, see
the <a href="#method.rsplit_once_str"><code>ByteSlice::rsplit_once_str</code></a> method .</p>
<h5 id="examples-30"><a href="#examples-30">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="macro">assert_eq!</span>(
    B(<span class="string">&quot;foo,bar&quot;</span>).split_once_str(<span class="string">&quot;,&quot;</span>),
    <span class="prelude-val">Some</span>((B(<span class="string">&quot;foo&quot;</span>), B(<span class="string">&quot;bar&quot;</span>))),
);
<span class="macro">assert_eq!</span>(
    B(<span class="string">&quot;foo,bar,baz&quot;</span>).split_once_str(<span class="string">&quot;,&quot;</span>),
    <span class="prelude-val">Some</span>((B(<span class="string">&quot;foo&quot;</span>), B(<span class="string">&quot;bar,baz&quot;</span>))),
);
<span class="macro">assert_eq!</span>(B(<span class="string">&quot;foo&quot;</span>).split_once_str(<span class="string">&quot;,&quot;</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(B(<span class="string">&quot;foo,&quot;</span>).split_once_str(<span class="string">b&quot;,&quot;</span>), <span class="prelude-val">Some</span>((B(<span class="string">&quot;foo&quot;</span>), B(<span class="string">&quot;&quot;</span>))));
<span class="macro">assert_eq!</span>(B(<span class="string">&quot;,foo&quot;</span>).split_once_str(<span class="string">b&quot;,&quot;</span>), <span class="prelude-val">Some</span>((B(<span class="string">&quot;&quot;</span>), B(<span class="string">&quot;foo&quot;</span>))));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rsplit_once_str" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#1409-1418">source</a><h4 class="code-header">fn <a href="#method.rsplit_once_str" class="fn">rsplit_once_str</a>&lt;'a, B: ?<a class="trait" href="https://doc.rust-lang.org/1.74.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;&gt;(
    &amp;'a self,
    splitter: <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.reference.html">&amp;B</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(&amp;'a [<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>], &amp;'a [<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>])&gt;</h4></section></summary><div class="docblock"><p>Split this byte string at the last occurrence of <code>splitter</code>.</p>
<p>If the <code>splitter</code> is found in the byte string, returns a tuple
containing the parts of the string before and after the last occurrence
of <code>splitter</code>, respectively. Otherwise, if there are no occurrences of
<code>splitter</code> in the byte string, returns <code>None</code>.</p>
<p>The splitter may be any type that can be cheaply converted into a
<code>&amp;[u8]</code>. This includes, but is not limited to, <code>&amp;str</code> and <code>&amp;[u8]</code>.</p>
<p>If you need to split on the <em>first</em> instance of a delimiter instead, see
the <a href="#method.split_once_str"><code>ByteSlice::split_once_str</code></a> method.</p>
<h5 id="examples-31"><a href="#examples-31">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="macro">assert_eq!</span>(
    B(<span class="string">&quot;foo,bar&quot;</span>).rsplit_once_str(<span class="string">&quot;,&quot;</span>),
    <span class="prelude-val">Some</span>((B(<span class="string">&quot;foo&quot;</span>), B(<span class="string">&quot;bar&quot;</span>))),
);
<span class="macro">assert_eq!</span>(
    B(<span class="string">&quot;foo,bar,baz&quot;</span>).rsplit_once_str(<span class="string">&quot;,&quot;</span>),
    <span class="prelude-val">Some</span>((B(<span class="string">&quot;foo,bar&quot;</span>), B(<span class="string">&quot;baz&quot;</span>))),
);
<span class="macro">assert_eq!</span>(B(<span class="string">&quot;foo&quot;</span>).rsplit_once_str(<span class="string">&quot;,&quot;</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(B(<span class="string">&quot;foo,&quot;</span>).rsplit_once_str(<span class="string">b&quot;,&quot;</span>), <span class="prelude-val">Some</span>((B(<span class="string">&quot;foo&quot;</span>), B(<span class="string">&quot;&quot;</span>))));
<span class="macro">assert_eq!</span>(B(<span class="string">&quot;,foo&quot;</span>).rsplit_once_str(<span class="string">b&quot;,&quot;</span>), <span class="prelude-val">Some</span>((B(<span class="string">&quot;&quot;</span>), B(<span class="string">&quot;foo&quot;</span>))));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.splitn_str" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#1456-1462">source</a><h4 class="code-header">fn <a href="#method.splitn_str" class="fn">splitn_str</a>&lt;'h, 's, B: ?<a class="trait" href="https://doc.rust-lang.org/1.74.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;&gt;(
    &amp;'h self,
    limit: <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a>,
    splitter: <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.reference.html">&amp;'s B</a>
) -&gt; <a class="struct" href="struct.SplitN.html" title="struct bstr::SplitN">SplitN</a>&lt;'h, 's&gt; <a href="#" class="tooltip" data-notable-ty="SplitN&lt;&#39;h, &#39;s&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator of at most <code>limit</code> substrings of this byte string,
separated by the given byte string. If <code>limit</code> substrings are yielded,
then the last substring will contain the remainder of this byte string.</p>
<p>The needle may be any type that can be cheaply converted into a
<code>&amp;[u8]</code>. This includes, but is not limited to, <code>&amp;str</code> and <code>&amp;[u8]</code>.</p>
<h5 id="examples-32"><a href="#examples-32">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>x: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">b&quot;Mary had a little lamb&quot;</span>.splitn_str(<span class="number">3</span>, <span class="string">&quot; &quot;</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[B(<span class="string">&quot;Mary&quot;</span>), B(<span class="string">&quot;had&quot;</span>), B(<span class="string">&quot;a little lamb&quot;</span>)]);

<span class="kw">let </span>x: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">b&quot;&quot;</span>.splitn_str(<span class="number">3</span>, <span class="string">&quot;X&quot;</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[<span class="string">b&quot;&quot;</span>]);

<span class="kw">let </span>x: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">b&quot;lionXXtigerXleopard&quot;</span>.splitn_str(<span class="number">3</span>, <span class="string">&quot;X&quot;</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[B(<span class="string">&quot;lion&quot;</span>), B(<span class="string">&quot;&quot;</span>), B(<span class="string">&quot;tigerXleopard&quot;</span>)]);

<span class="kw">let </span>x: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">b&quot;lion::tiger::leopard&quot;</span>.splitn_str(<span class="number">2</span>, <span class="string">&quot;::&quot;</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[B(<span class="string">&quot;lion&quot;</span>), B(<span class="string">&quot;tiger::leopard&quot;</span>)]);

<span class="kw">let </span>x: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">b&quot;abcXdef&quot;</span>.splitn_str(<span class="number">1</span>, <span class="string">&quot;X&quot;</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[B(<span class="string">&quot;abcXdef&quot;</span>)]);

<span class="kw">let </span>x: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">b&quot;abcdef&quot;</span>.splitn_str(<span class="number">2</span>, <span class="string">&quot;X&quot;</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[B(<span class="string">&quot;abcdef&quot;</span>)]);

<span class="kw">let </span>x: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">b&quot;abcXdef&quot;</span>.splitn_str(<span class="number">0</span>, <span class="string">&quot;X&quot;</span>).collect();
<span class="macro">assert!</span>(x.is_empty());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rsplitn_str" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#1502-1508">source</a><h4 class="code-header">fn <a href="#method.rsplitn_str" class="fn">rsplitn_str</a>&lt;'h, 's, B: ?<a class="trait" href="https://doc.rust-lang.org/1.74.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;&gt;(
    &amp;'h self,
    limit: <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a>,
    splitter: <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.reference.html">&amp;'s B</a>
) -&gt; <a class="struct" href="struct.SplitNReverse.html" title="struct bstr::SplitNReverse">SplitNReverse</a>&lt;'h, 's&gt; <a href="#" class="tooltip" data-notable-ty="SplitNReverse&lt;&#39;h, &#39;s&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator of at most <code>limit</code> substrings of this byte string,
separated by the given byte string, in reverse. If <code>limit</code> substrings
are yielded, then the last substring will contain the remainder of this
byte string.</p>
<p>The needle may be any type that can be cheaply converted into a
<code>&amp;[u8]</code>. This includes, but is not limited to, <code>&amp;str</code> and <code>&amp;[u8]</code>.</p>
<h5 id="examples-33"><a href="#examples-33">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>x: Vec&lt;<span class="kw">_</span>&gt; =
    <span class="string">b&quot;Mary had a little lamb&quot;</span>.rsplitn_str(<span class="number">3</span>, <span class="string">&quot; &quot;</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[B(<span class="string">&quot;lamb&quot;</span>), B(<span class="string">&quot;little&quot;</span>), B(<span class="string">&quot;Mary had a&quot;</span>)]);

<span class="kw">let </span>x: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">b&quot;&quot;</span>.rsplitn_str(<span class="number">3</span>, <span class="string">&quot;X&quot;</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[<span class="string">b&quot;&quot;</span>]);

<span class="kw">let </span>x: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">b&quot;lionXXtigerXleopard&quot;</span>.rsplitn_str(<span class="number">3</span>, <span class="string">&quot;X&quot;</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[B(<span class="string">&quot;leopard&quot;</span>), B(<span class="string">&quot;tiger&quot;</span>), B(<span class="string">&quot;lionX&quot;</span>)]);

<span class="kw">let </span>x: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">b&quot;lion::tiger::leopard&quot;</span>.rsplitn_str(<span class="number">2</span>, <span class="string">&quot;::&quot;</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[B(<span class="string">&quot;leopard&quot;</span>), B(<span class="string">&quot;lion::tiger&quot;</span>)]);

<span class="kw">let </span>x: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">b&quot;abcXdef&quot;</span>.rsplitn_str(<span class="number">1</span>, <span class="string">&quot;X&quot;</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[B(<span class="string">&quot;abcXdef&quot;</span>)]);

<span class="kw">let </span>x: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">b&quot;abcdef&quot;</span>.rsplitn_str(<span class="number">2</span>, <span class="string">&quot;X&quot;</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[B(<span class="string">&quot;abcdef&quot;</span>)]);

<span class="kw">let </span>x: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">b&quot;abcXdef&quot;</span>.rsplitn_str(<span class="number">0</span>, <span class="string">&quot;X&quot;</span>).collect();
<span class="macro">assert!</span>(x.is_empty());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.replace" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#1546-1554">source</a><h4 class="code-header">fn <a href="#method.replace" class="fn">replace</a>&lt;N: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;, R: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;&gt;(
    &amp;self,
    needle: N,
    replacement: R
) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.74.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>&gt; <a href="#" class="tooltip" data-notable-ty="Vec&lt;u8&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Replace all matches of the given needle with the given replacement, and
the result as a new <code>Vec&lt;u8&gt;</code>.</p>
<p>This routine is useful as a convenience. If you need to reuse an
allocation, use <a href="#method.replace_into"><code>replace_into</code></a> instead.</p>
<h5 id="examples-34"><a href="#examples-34">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>s = <span class="string">b&quot;this is old&quot;</span>.replace(<span class="string">&quot;old&quot;</span>, <span class="string">&quot;new&quot;</span>);
<span class="macro">assert_eq!</span>(s, <span class="string">&quot;this is new&quot;</span>.as_bytes());</code></pre></div>
<p>When the pattern doesn’t match:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>s = <span class="string">b&quot;this is old&quot;</span>.replace(<span class="string">&quot;nada nada&quot;</span>, <span class="string">&quot;limonada&quot;</span>);
<span class="macro">assert_eq!</span>(s, <span class="string">&quot;this is old&quot;</span>.as_bytes());</code></pre></div>
<p>When the needle is an empty string:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>s = <span class="string">b&quot;foo&quot;</span>.replace(<span class="string">&quot;&quot;</span>, <span class="string">&quot;Z&quot;</span>);
<span class="macro">assert_eq!</span>(s, <span class="string">&quot;ZfZoZoZ&quot;</span>.as_bytes());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.replacen" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#1592-1601">source</a><h4 class="code-header">fn <a href="#method.replacen" class="fn">replacen</a>&lt;N: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;, R: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;&gt;(
    &amp;self,
    needle: N,
    replacement: R,
    limit: <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a>
) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.74.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>&gt; <a href="#" class="tooltip" data-notable-ty="Vec&lt;u8&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Replace up to <code>limit</code> matches of the given needle with the given
replacement, and the result as a new <code>Vec&lt;u8&gt;</code>.</p>
<p>This routine is useful as a convenience. If you need to reuse an
allocation, use <a href="#method.replacen_into"><code>replacen_into</code></a> instead.</p>
<h5 id="examples-35"><a href="#examples-35">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>s = <span class="string">b&quot;foofoo&quot;</span>.replacen(<span class="string">&quot;o&quot;</span>, <span class="string">&quot;z&quot;</span>, <span class="number">2</span>);
<span class="macro">assert_eq!</span>(s, <span class="string">&quot;fzzfoo&quot;</span>.as_bytes());</code></pre></div>
<p>When the pattern doesn’t match:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>s = <span class="string">b&quot;foofoo&quot;</span>.replacen(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;z&quot;</span>, <span class="number">2</span>);
<span class="macro">assert_eq!</span>(s, <span class="string">&quot;foofoo&quot;</span>.as_bytes());</code></pre></div>
<p>When the needle is an empty string:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>s = <span class="string">b&quot;foo&quot;</span>.replacen(<span class="string">&quot;&quot;</span>, <span class="string">&quot;Z&quot;</span>, <span class="number">2</span>);
<span class="macro">assert_eq!</span>(s, <span class="string">&quot;ZfZoo&quot;</span>.as_bytes());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.replace_into" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#1650-1665">source</a><h4 class="code-header">fn <a href="#method.replace_into" class="fn">replace_into</a>&lt;N: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;, R: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;&gt;(
    &amp;self,
    needle: N,
    replacement: R,
    dest: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.74.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>&gt;
)</h4></section></summary><div class="docblock"><p>Replace all matches of the given needle with the given replacement,
and write the result into the provided <code>Vec&lt;u8&gt;</code>.</p>
<p>This does <strong>not</strong> clear <code>dest</code> before writing to it.</p>
<p>This routine is useful for reusing allocation. For a more convenient
API, use <a href="#method.replace"><code>replace</code></a> instead.</p>
<h5 id="examples-36"><a href="#examples-36">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>s = <span class="string">b&quot;this is old&quot;</span>;

<span class="kw">let </span><span class="kw-2">mut </span>dest = <span class="macro">vec!</span>[];
s.replace_into(<span class="string">&quot;old&quot;</span>, <span class="string">&quot;new&quot;</span>, <span class="kw-2">&amp;mut </span>dest);
<span class="macro">assert_eq!</span>(dest, <span class="string">&quot;this is new&quot;</span>.as_bytes());</code></pre></div>
<p>When the pattern doesn’t match:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>s = <span class="string">b&quot;this is old&quot;</span>;

<span class="kw">let </span><span class="kw-2">mut </span>dest = <span class="macro">vec!</span>[];
s.replace_into(<span class="string">&quot;nada nada&quot;</span>, <span class="string">&quot;limonada&quot;</span>, <span class="kw-2">&amp;mut </span>dest);
<span class="macro">assert_eq!</span>(dest, <span class="string">&quot;this is old&quot;</span>.as_bytes());</code></pre></div>
<p>When the needle is an empty string:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>s = <span class="string">b&quot;foo&quot;</span>;

<span class="kw">let </span><span class="kw-2">mut </span>dest = <span class="macro">vec!</span>[];
s.replace_into(<span class="string">&quot;&quot;</span>, <span class="string">&quot;Z&quot;</span>, <span class="kw-2">&amp;mut </span>dest);
<span class="macro">assert_eq!</span>(dest, <span class="string">&quot;ZfZoZoZ&quot;</span>.as_bytes());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.replacen_into" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#1714-1730">source</a><h4 class="code-header">fn <a href="#method.replacen_into" class="fn">replacen_into</a>&lt;N: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;, R: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]&gt;&gt;(
    &amp;self,
    needle: N,
    replacement: R,
    limit: <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a>,
    dest: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.74.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>&gt;
)</h4></section></summary><div class="docblock"><p>Replace up to <code>limit</code> matches of the given needle with the given
replacement, and write the result into the provided <code>Vec&lt;u8&gt;</code>.</p>
<p>This does <strong>not</strong> clear <code>dest</code> before writing to it.</p>
<p>This routine is useful for reusing allocation. For a more convenient
API, use <a href="#method.replacen"><code>replacen</code></a> instead.</p>
<h5 id="examples-37"><a href="#examples-37">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>s = <span class="string">b&quot;foofoo&quot;</span>;

<span class="kw">let </span><span class="kw-2">mut </span>dest = <span class="macro">vec!</span>[];
s.replacen_into(<span class="string">&quot;o&quot;</span>, <span class="string">&quot;z&quot;</span>, <span class="number">2</span>, <span class="kw-2">&amp;mut </span>dest);
<span class="macro">assert_eq!</span>(dest, <span class="string">&quot;fzzfoo&quot;</span>.as_bytes());</code></pre></div>
<p>When the pattern doesn’t match:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>s = <span class="string">b&quot;foofoo&quot;</span>;

<span class="kw">let </span><span class="kw-2">mut </span>dest = <span class="macro">vec!</span>[];
s.replacen_into(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;z&quot;</span>, <span class="number">2</span>, <span class="kw-2">&amp;mut </span>dest);
<span class="macro">assert_eq!</span>(dest, <span class="string">&quot;foofoo&quot;</span>.as_bytes());</code></pre></div>
<p>When the needle is an empty string:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>s = <span class="string">b&quot;foo&quot;</span>;

<span class="kw">let </span><span class="kw-2">mut </span>dest = <span class="macro">vec!</span>[];
s.replacen_into(<span class="string">&quot;&quot;</span>, <span class="string">&quot;Z&quot;</span>, <span class="number">2</span>, <span class="kw-2">&amp;mut </span>dest);
<span class="macro">assert_eq!</span>(dest, <span class="string">&quot;ZfZoo&quot;</span>.as_bytes());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.bytes" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#1746-1748">source</a><h4 class="code-header">fn <a href="#method.bytes" class="fn">bytes</a>(&amp;self) -&gt; <a class="struct" href="struct.Bytes.html" title="struct bstr::Bytes">Bytes</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="Bytes&lt;&#39;_&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator over the bytes in this byte string.</p>
<h5 id="examples-38"><a href="#examples-38">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>bs = <span class="string">b&quot;foobar&quot;</span>;
<span class="kw">let </span>bytes: Vec&lt;u8&gt; = bs.bytes().collect();
<span class="macro">assert_eq!</span>(bytes, bs);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.chars" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#1776-1778">source</a><h4 class="code-header">fn <a href="#method.chars" class="fn">chars</a>(&amp;self) -&gt; <a class="struct" href="struct.Chars.html" title="struct bstr::Chars">Chars</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="Chars&lt;&#39;_&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator over the Unicode scalar values in this byte string.
If invalid UTF-8 is encountered, then the Unicode replacement codepoint
is yielded instead.</p>
<h5 id="examples-39"><a href="#examples-39">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>bs = <span class="string">b&quot;\xE2\x98\x83\xFF\xF0\x9D\x9E\x83\xE2\x98\x61&quot;</span>;
<span class="kw">let </span>chars: Vec&lt;char&gt; = bs.chars().collect();
<span class="macro">assert_eq!</span>(<span class="macro">vec!</span>[<span class="string">&#39;☃&#39;</span>, <span class="string">&#39;\u{FFFD}&#39;</span>, <span class="string">&#39;𝞃&#39;</span>, <span class="string">&#39;\u{FFFD}&#39;</span>, <span class="string">&#39;a&#39;</span>], chars);</code></pre></div>
<p>Codepoints can also be iterated over in reverse:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>bs = <span class="string">b&quot;\xE2\x98\x83\xFF\xF0\x9D\x9E\x83\xE2\x98\x61&quot;</span>;
<span class="kw">let </span>chars: Vec&lt;char&gt; = bs.chars().rev().collect();
<span class="macro">assert_eq!</span>(<span class="macro">vec!</span>[<span class="string">&#39;a&#39;</span>, <span class="string">&#39;\u{FFFD}&#39;</span>, <span class="string">&#39;𝞃&#39;</span>, <span class="string">&#39;\u{FFFD}&#39;</span>, <span class="string">&#39;☃&#39;</span>], chars);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.char_indices" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#1831-1833">source</a><h4 class="code-header">fn <a href="#method.char_indices" class="fn">char_indices</a>(&amp;self) -&gt; <a class="struct" href="struct.CharIndices.html" title="struct bstr::CharIndices">CharIndices</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="CharIndices&lt;&#39;_&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator over the Unicode scalar values in this byte string
along with their starting and ending byte index positions. If invalid
UTF-8 is encountered, then the Unicode replacement codepoint is yielded
instead.</p>
<p>Note that this is slightly different from the <code>CharIndices</code> iterator
provided by the standard library. Aside from working on possibly
invalid UTF-8, this iterator provides both the corresponding starting
and ending byte indices of each codepoint yielded. The ending position
is necessary to slice the original byte string when invalid UTF-8 bytes
are converted into a Unicode replacement codepoint, since a single
replacement codepoint can substitute anywhere from 1 to 3 invalid bytes
(inclusive).</p>
<h5 id="examples-40"><a href="#examples-40">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>bs = <span class="string">b&quot;\xE2\x98\x83\xFF\xF0\x9D\x9E\x83\xE2\x98\x61&quot;</span>;
<span class="kw">let </span>chars: Vec&lt;(usize, usize, char)&gt; = bs.char_indices().collect();
<span class="macro">assert_eq!</span>(chars, <span class="macro">vec!</span>[
    (<span class="number">0</span>, <span class="number">3</span>, <span class="string">&#39;☃&#39;</span>),
    (<span class="number">3</span>, <span class="number">4</span>, <span class="string">&#39;\u{FFFD}&#39;</span>),
    (<span class="number">4</span>, <span class="number">8</span>, <span class="string">&#39;𝞃&#39;</span>),
    (<span class="number">8</span>, <span class="number">10</span>, <span class="string">&#39;\u{FFFD}&#39;</span>),
    (<span class="number">10</span>, <span class="number">11</span>, <span class="string">&#39;a&#39;</span>),
]);</code></pre></div>
<p>Codepoints can also be iterated over in reverse:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>bs = <span class="string">b&quot;\xE2\x98\x83\xFF\xF0\x9D\x9E\x83\xE2\x98\x61&quot;</span>;
<span class="kw">let </span>chars: Vec&lt;(usize, usize, char)&gt; = bs
    .char_indices()
    .rev()
    .collect();
<span class="macro">assert_eq!</span>(chars, <span class="macro">vec!</span>[
    (<span class="number">10</span>, <span class="number">11</span>, <span class="string">&#39;a&#39;</span>),
    (<span class="number">8</span>, <span class="number">10</span>, <span class="string">&#39;\u{FFFD}&#39;</span>),
    (<span class="number">4</span>, <span class="number">8</span>, <span class="string">&#39;𝞃&#39;</span>),
    (<span class="number">3</span>, <span class="number">4</span>, <span class="string">&#39;\u{FFFD}&#39;</span>),
    (<span class="number">0</span>, <span class="number">3</span>, <span class="string">&#39;☃&#39;</span>),
]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.utf8_chunks" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#1868-1870">source</a><h4 class="code-header">fn <a href="#method.utf8_chunks" class="fn">utf8_chunks</a>(&amp;self) -&gt; <a class="struct" href="struct.Utf8Chunks.html" title="struct bstr::Utf8Chunks">Utf8Chunks</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="Utf8Chunks&lt;&#39;_&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Iterate over chunks of valid UTF-8.</p>
<p>The iterator returned yields chunks of valid UTF-8 separated by invalid
UTF-8 bytes, if they exist. Invalid UTF-8 bytes are always 1-3 bytes,
which are determined via the “substitution of maximal subparts”
strategy described in the docs for the
<a href="trait.ByteSlice.html#method.to_str_lossy"><code>ByteSlice::to_str_lossy</code></a>
method.</p>
<h5 id="examples-41"><a href="#examples-41">Examples</a></h5>
<p>This example shows how to gather all valid and invalid chunks from a
byte slice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{ByteSlice, Utf8Chunk};

<span class="kw">let </span>bytes = <span class="string">b&quot;foo\xFD\xFEbar\xFF&quot;</span>;

<span class="kw">let </span>(<span class="kw-2">mut </span>valid_chunks, <span class="kw-2">mut </span>invalid_chunks) = (<span class="macro">vec!</span>[], <span class="macro">vec!</span>[]);
<span class="kw">for </span>chunk <span class="kw">in </span>bytes.utf8_chunks() {
    <span class="kw">if </span>!chunk.valid().is_empty() {
        valid_chunks.push(chunk.valid());
    }
    <span class="kw">if </span>!chunk.invalid().is_empty() {
        invalid_chunks.push(chunk.invalid());
    }
}

<span class="macro">assert_eq!</span>(valid_chunks, <span class="macro">vec!</span>[<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>]);
<span class="macro">assert_eq!</span>(invalid_chunks, <span class="macro">vec!</span>[<span class="string">b&quot;\xFD&quot;</span>, <span class="string">b&quot;\xFE&quot;</span>, <span class="string">b&quot;\xFF&quot;</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.lines" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#2184-2186">source</a><h4 class="code-header">fn <a href="#method.lines" class="fn">lines</a>(&amp;self) -&gt; <a class="struct" href="struct.Lines.html" title="struct bstr::Lines">Lines</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="Lines&lt;&#39;_&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>An iterator over all lines in a byte string, without their
terminators.</p>
<p>For this iterator, the only line terminators recognized are <code>\r\n</code> and
<code>\n</code>.</p>
<h5 id="examples-42"><a href="#examples-42">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>s = <span class="string">b&quot;\
foo

bar\r
baz


quux&quot;</span>;
<span class="kw">let </span>lines: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = s.lines().collect();
<span class="macro">assert_eq!</span>(lines, <span class="macro">vec!</span>[
    B(<span class="string">&quot;foo&quot;</span>), B(<span class="string">&quot;&quot;</span>), B(<span class="string">&quot;bar&quot;</span>), B(<span class="string">&quot;baz&quot;</span>), B(<span class="string">&quot;&quot;</span>), B(<span class="string">&quot;&quot;</span>), B(<span class="string">&quot;quux&quot;</span>),
]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.lines_with_terminator" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#2228-2230">source</a><h4 class="code-header">fn <a href="#method.lines_with_terminator" class="fn">lines_with_terminator</a>(&amp;self) -&gt; <a class="struct" href="struct.LinesWithTerminator.html" title="struct bstr::LinesWithTerminator">LinesWithTerminator</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="LinesWithTerminator&lt;&#39;_&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>An iterator over all lines in a byte string, including their
terminators.</p>
<p>For this iterator, the only line terminator recognized is <code>\n</code>. (Since
line terminators are included, this also handles <code>\r\n</code> line endings.)</p>
<p>Line terminators are only included if they are present in the original
byte string. For example, the last line in a byte string may not end
with a line terminator.</p>
<p>Concatenating all elements yielded by this iterator is guaranteed to
yield the original byte string.</p>
<h5 id="examples-43"><a href="#examples-43">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>s = <span class="string">b&quot;\
foo

bar\r
baz


quux&quot;</span>;
<span class="kw">let </span>lines: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = s.lines_with_terminator().collect();
<span class="macro">assert_eq!</span>(lines, <span class="macro">vec!</span>[
    B(<span class="string">&quot;foo\n&quot;</span>),
    B(<span class="string">&quot;\n&quot;</span>),
    B(<span class="string">&quot;bar\r\n&quot;</span>),
    B(<span class="string">&quot;baz\n&quot;</span>),
    B(<span class="string">&quot;\n&quot;</span>),
    B(<span class="string">&quot;\n&quot;</span>),
    B(<span class="string">&quot;quux&quot;</span>),
]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_with" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#2312-2314">source</a><h4 class="code-header">fn <a href="#method.trim_with" class="fn">trim_with</a>&lt;F: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html">char</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.bool.html">bool</a>&gt;(&amp;self, trim: F) -&gt; &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;[u8]">ⓘ</a></h4></section></summary><div class="docblock"><p>Return a byte string slice with leading and trailing characters
satisfying the given predicate removed.</p>
<h5 id="examples-44"><a href="#examples-44">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>s = <span class="string">b&quot;123foo5bar789&quot;</span>;
<span class="macro">assert_eq!</span>(s.trim_with(|c| c.is_numeric()), B(<span class="string">&quot;foo5bar&quot;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_start_with" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#2330-2337">source</a><h4 class="code-header">fn <a href="#method.trim_start_with" class="fn">trim_start_with</a>&lt;F: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html">char</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.bool.html">bool</a>&gt;(&amp;self, trim: F) -&gt; &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;[u8]">ⓘ</a></h4></section></summary><div class="docblock"><p>Return a byte string slice with leading characters satisfying the given
predicate removed.</p>
<h5 id="examples-45"><a href="#examples-45">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>s = <span class="string">b&quot;123foo5bar789&quot;</span>;
<span class="macro">assert_eq!</span>(s.trim_start_with(|c| c.is_numeric()), B(<span class="string">&quot;foo5bar789&quot;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_end_with" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#2353-2360">source</a><h4 class="code-header">fn <a href="#method.trim_end_with" class="fn">trim_end_with</a>&lt;F: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html">char</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.bool.html">bool</a>&gt;(&amp;self, trim: F) -&gt; &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;[u8]">ⓘ</a></h4></section></summary><div class="docblock"><p>Return a byte string slice with trailing characters satisfying the
given predicate removed.</p>
<h5 id="examples-46"><a href="#examples-46">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>s = <span class="string">b&quot;123foo5bar789&quot;</span>;
<span class="macro">assert_eq!</span>(s.trim_end_with(|c| c.is_numeric()), B(<span class="string">&quot;123foo5bar&quot;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_ascii_lowercase" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#2526-2528">source</a><h4 class="code-header">fn <a href="#method.to_ascii_lowercase" class="fn">to_ascii_lowercase</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.74.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>&gt; <a href="#" class="tooltip" data-notable-ty="Vec&lt;u8&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns a new <code>Vec&lt;u8&gt;</code> containing the ASCII lowercase equivalent of
this byte string.</p>
<p>In this case, lowercase is only defined in ASCII letters. Namely, the
letters <code>A-Z</code> are converted to <code>a-z</code>. All other bytes remain unchanged.
In particular, the length of the byte string returned is always
equivalent to the length of this byte string.</p>
<p>If you’d like to reuse an allocation for performance reasons, then use
<a href="#method.make_ascii_lowercase"><code>make_ascii_lowercase</code></a> to perform
the conversion in place.</p>
<h5 id="examples-47"><a href="#examples-47">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>s = B(<span class="string">&quot;HELLO Β&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;hello Β&quot;</span>.as_bytes(), s.to_ascii_lowercase().as_bytes());</code></pre></div>
<p>Invalid UTF-8 remains as is:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>s = B(<span class="string">b&quot;FOO\xFFBAR\xE2\x98BAZ&quot;</span>);
<span class="macro">assert_eq!</span>(s.to_ascii_lowercase(), B(<span class="string">b&quot;foo\xFFbar\xE2\x98baz&quot;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.make_ascii_lowercase" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#2563-2565">source</a><h4 class="code-header">fn <a href="#method.make_ascii_lowercase" class="fn">make_ascii_lowercase</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Convert this byte string to its lowercase ASCII equivalent in place.</p>
<p>In this case, lowercase is only defined in ASCII letters. Namely, the
letters <code>A-Z</code> are converted to <code>a-z</code>. All other bytes remain unchanged.</p>
<p>If you don’t need to do the conversion in
place and instead prefer convenience, then use
<a href="#method.to_ascii_lowercase"><code>to_ascii_lowercase</code></a> instead.</p>
<h5 id="examples-48"><a href="#examples-48">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span><span class="kw-2">mut </span>s = &lt;Vec&lt;u8&gt;&gt;::from(<span class="string">&quot;HELLO Β&quot;</span>);
s.make_ascii_lowercase();
<span class="macro">assert_eq!</span>(s, <span class="string">&quot;hello Β&quot;</span>.as_bytes());</code></pre></div>
<p>Invalid UTF-8 remains as is:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice, ByteVec};

<span class="kw">let </span><span class="kw-2">mut </span>s = &lt;Vec&lt;u8&gt;&gt;::from_slice(<span class="string">b&quot;FOO\xFFBAR\xE2\x98BAZ&quot;</span>);
s.make_ascii_lowercase();
<span class="macro">assert_eq!</span>(s, B(<span class="string">b&quot;foo\xFFbar\xE2\x98baz&quot;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_ascii_uppercase" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#2728-2730">source</a><h4 class="code-header">fn <a href="#method.to_ascii_uppercase" class="fn">to_ascii_uppercase</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.74.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>&gt; <a href="#" class="tooltip" data-notable-ty="Vec&lt;u8&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns a new <code>Vec&lt;u8&gt;</code> containing the ASCII uppercase equivalent of
this byte string.</p>
<p>In this case, uppercase is only defined in ASCII letters. Namely, the
letters <code>a-z</code> are converted to <code>A-Z</code>. All other bytes remain unchanged.
In particular, the length of the byte string returned is always
equivalent to the length of this byte string.</p>
<p>If you’d like to reuse an allocation for performance reasons, then use
<a href="#method.make_ascii_uppercase"><code>make_ascii_uppercase</code></a> to perform
the conversion in place.</p>
<h5 id="examples-49"><a href="#examples-49">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>s = B(<span class="string">&quot;hello β&quot;</span>);
<span class="macro">assert_eq!</span>(s.to_ascii_uppercase(), B(<span class="string">&quot;HELLO β&quot;</span>));</code></pre></div>
<p>Invalid UTF-8 remains as is:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>s = B(<span class="string">b&quot;foo\xFFbar\xE2\x98baz&quot;</span>);
<span class="macro">assert_eq!</span>(s.to_ascii_uppercase(), B(<span class="string">b&quot;FOO\xFFBAR\xE2\x98BAZ&quot;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.make_ascii_uppercase" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#2765-2767">source</a><h4 class="code-header">fn <a href="#method.make_ascii_uppercase" class="fn">make_ascii_uppercase</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Convert this byte string to its uppercase ASCII equivalent in place.</p>
<p>In this case, uppercase is only defined in ASCII letters. Namely, the
letters <code>a-z</code> are converted to <code>A-Z</code>. All other bytes remain unchanged.</p>
<p>If you don’t need to do the conversion in
place and instead prefer convenience, then use
<a href="#method.to_ascii_uppercase"><code>to_ascii_uppercase</code></a> instead.</p>
<h5 id="examples-50"><a href="#examples-50">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span><span class="kw-2">mut </span>s = &lt;Vec&lt;u8&gt;&gt;::from(<span class="string">&quot;hello β&quot;</span>);
s.make_ascii_uppercase();
<span class="macro">assert_eq!</span>(s, B(<span class="string">&quot;HELLO β&quot;</span>));</code></pre></div>
<p>Invalid UTF-8 remains as is:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice, ByteVec};

<span class="kw">let </span><span class="kw-2">mut </span>s = &lt;Vec&lt;u8&gt;&gt;::from_slice(<span class="string">b&quot;foo\xFFbar\xE2\x98baz&quot;</span>);
s.make_ascii_uppercase();
<span class="macro">assert_eq!</span>(s, B(<span class="string">b&quot;FOO\xFFBAR\xE2\x98BAZ&quot;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.escape_bytes" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#2806-2808">source</a><h4 class="code-header">fn <a href="#method.escape_bytes" class="fn">escape_bytes</a>(&amp;self) -&gt; <a class="struct" href="struct.EscapeBytes.html" title="struct bstr::EscapeBytes">EscapeBytes</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="EscapeBytes&lt;&#39;_&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Escapes this byte string into a sequence of <code>char</code> values.</p>
<p>When the sequence of <code>char</code> values is concatenated into a string, the
result is always valid UTF-8. Any unprintable or invalid UTF-8 in this
byte string are escaped using using <code>\xNN</code> notation. Moreover, the
characters <code>\0</code>, <code>\r</code>, <code>\n</code>, <code>\t</code> and <code>\</code> are escaped as well.</p>
<p>This is useful when one wants to get a human readable view of the raw
bytes that is also valid UTF-8.</p>
<p>The iterator returned implements the <code>Display</code> trait. So one can do
<code>b&quot;foo\xFFbar&quot;.escape_bytes().to_string()</code> to get a <code>String</code> with its
bytes escaped.</p>
<p>The dual of this function is <a href="trait.ByteVec.html#method.unescape_bytes" title="associated function bstr::ByteVec::unescape_bytes"><code>ByteVec::unescape_bytes</code></a>.</p>
<p>Note that this is similar to, but not equivalent to the <code>Debug</code>
implementation on <a href="struct.BStr.html" title="struct bstr::BStr"><code>BStr</code></a> and [<code>BString</code>]. The <code>Debug</code> implementations
also use the debug representation for all Unicode codepoints. However,
this escaping routine only escapes individual bytes. All Unicode
codepoints above <code>U+007F</code> are passed through unchanged without any
escaping.</p>
<h5 id="examples-51"><a href="#examples-51">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="macro">assert_eq!</span>(<span class="string">r&quot;foo\xFFbar&quot;</span>, <span class="string">b&quot;foo\xFFbar&quot;</span>.escape_bytes().to_string());
<span class="macro">assert_eq!</span>(<span class="string">r&quot;foo\nbar&quot;</span>, <span class="string">b&quot;foo\nbar&quot;</span>.escape_bytes().to_string());
<span class="macro">assert_eq!</span>(<span class="string">r&quot;foo\tbar&quot;</span>, <span class="string">b&quot;foo\tbar&quot;</span>.escape_bytes().to_string());
<span class="macro">assert_eq!</span>(<span class="string">r&quot;foo\\bar&quot;</span>, <span class="string">b&quot;foo\\bar&quot;</span>.escape_bytes().to_string());
<span class="macro">assert_eq!</span>(<span class="string">r&quot;foo☃bar&quot;</span>, B(<span class="string">&quot;foo☃bar&quot;</span>).escape_bytes().to_string());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.reverse_bytes" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#2833-2835">source</a><h4 class="code-header">fn <a href="#method.reverse_bytes" class="fn">reverse_bytes</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Reverse the bytes in this string, in place.</p>
<p>This is not necessarily a well formed operation! For example, if this
byte string contains valid UTF-8 that isn’t ASCII, then reversing the
string will likely result in invalid UTF-8 and otherwise non-sensical
content.</p>
<p>Note that this is equivalent to the generic <code>[u8]::reverse</code> method.
This method is provided to permit callers to explicitly differentiate
between reversing bytes, codepoints and graphemes.</p>
<h5 id="examples-52"><a href="#examples-52">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span><span class="kw-2">mut </span>s = &lt;Vec&lt;u8&gt;&gt;::from(<span class="string">&quot;hello&quot;</span>);
s.reverse_bytes();
<span class="macro">assert_eq!</span>(s, <span class="string">&quot;olleh&quot;</span>.as_bytes());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.reverse_chars" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#2904-2917">source</a><h4 class="code-header">fn <a href="#method.reverse_chars" class="fn">reverse_chars</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Reverse the codepoints in this string, in place.</p>
<p>If this byte string is valid UTF-8, then its reversal by codepoint
is also guaranteed to be valid UTF-8.</p>
<p>This operation is equivalent to the following, but without allocating:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span><span class="kw-2">mut </span>s = &lt;Vec&lt;u8&gt;&gt;::from(<span class="string">&quot;foo☃bar&quot;</span>);

<span class="kw">let </span><span class="kw-2">mut </span>chars: Vec&lt;char&gt; = s.chars().collect();
chars.reverse();

<span class="kw">let </span>reversed: String = chars.into_iter().collect();
<span class="macro">assert_eq!</span>(reversed, <span class="string">&quot;rab☃oof&quot;</span>);</code></pre></div>
<p>Note that this is not necessarily a well formed operation. For example,
if this byte string contains grapheme clusters with more than one
codepoint, then those grapheme clusters will not necessarily be
preserved. If you’d like to preserve grapheme clusters, then use
<a href="#method.reverse_graphemes"><code>reverse_graphemes</code></a> instead.</p>
<h5 id="examples-53"><a href="#examples-53">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span><span class="kw-2">mut </span>s = &lt;Vec&lt;u8&gt;&gt;::from(<span class="string">&quot;foo☃bar&quot;</span>);
s.reverse_chars();
<span class="macro">assert_eq!</span>(s, <span class="string">&quot;rab☃oof&quot;</span>.as_bytes());</code></pre></div>
<p>This example shows that not all reversals lead to a well formed string.
For example, in this case, combining marks are used to put accents over
some letters, and those accent marks must appear after the codepoints
they modify.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span><span class="kw-2">mut </span>s = &lt;Vec&lt;u8&gt;&gt;::from(<span class="string">&quot;résumé&quot;</span>);
s.reverse_chars();
<span class="macro">assert_eq!</span>(s, B(<span class="string">b&quot;\xCC\x81emus\xCC\x81er&quot;</span>));</code></pre></div>
<p>A word of warning: the above example relies on the fact that
<code>résumé</code> is in decomposed normal form, which means there are separate
codepoints for the accents above <code>e</code>. If it is instead in composed
normal form, then the example works:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span><span class="kw-2">mut </span>s = &lt;Vec&lt;u8&gt;&gt;::from(<span class="string">&quot;résumé&quot;</span>);
s.reverse_chars();
<span class="macro">assert_eq!</span>(s, B(<span class="string">&quot;émusér&quot;</span>));</code></pre></div>
<p>The point here is to be cautious and not assume that just because
<code>reverse_chars</code> works in one case, that it therefore works in all
cases.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_ascii" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#2997-2999">source</a><h4 class="code-header">fn <a href="#method.is_ascii" class="fn">is_ascii</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if every byte in this byte string is ASCII.</p>
<p>ASCII is an encoding that defines 128 codepoints. A byte corresponds to
an ASCII codepoint if and only if it is in the inclusive range
<code>[0, 127]</code>.</p>
<h5 id="examples-54"><a href="#examples-54">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="macro">assert!</span>(B(<span class="string">&quot;abc&quot;</span>).is_ascii());
<span class="macro">assert!</span>(!B(<span class="string">&quot;☃βツ&quot;</span>).is_ascii());
<span class="macro">assert!</span>(!B(<span class="string">b&quot;\xFF&quot;</span>).is_ascii());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_utf8" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#3025-3027">source</a><h4 class="code-header">fn <a href="#method.is_utf8" class="fn">is_utf8</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if the entire byte string is valid UTF-8.</p>
<p>If you need location information about where a byte string’s first
invalid UTF-8 byte is, then use the <a href="#method.to_str"><code>to_str</code></a> method.</p>
<h5 id="examples-55"><a href="#examples-55">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="macro">assert!</span>(B(<span class="string">&quot;abc&quot;</span>).is_utf8());
<span class="macro">assert!</span>(B(<span class="string">&quot;☃βツ&quot;</span>).is_utf8());
<span class="comment">// invalid bytes
</span><span class="macro">assert!</span>(!B(<span class="string">b&quot;abc\xFF&quot;</span>).is_utf8());
<span class="comment">// surrogate encoding
</span><span class="macro">assert!</span>(!B(<span class="string">b&quot;\xED\xA0\x80&quot;</span>).is_utf8());
<span class="comment">// incomplete sequence
</span><span class="macro">assert!</span>(!B(<span class="string">b&quot;\xF0\x9D\x9Ca&quot;</span>).is_utf8());
<span class="comment">// overlong sequence
</span><span class="macro">assert!</span>(!B(<span class="string">b&quot;\xF0\x82\x82\xAC&quot;</span>).is_utf8());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.last_byte" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#3046-3049">source</a><h4 class="code-header">fn <a href="#method.last_byte" class="fn">last_byte</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the last byte in this byte string, if it’s non-empty. If this
byte string is empty, this returns <code>None</code>.</p>
<p>Note that this is like the generic <code>[u8]::last</code>, except this returns
the byte by value instead of a reference to the byte.</p>
<h5 id="examples-56"><a href="#examples-56">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">b&#39;z&#39;</span>), <span class="string">b&quot;baz&quot;</span>.last_byte());
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="string">b&quot;&quot;</span>.last_byte());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_non_ascii_byte" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#3067-3074">source</a><h4 class="code-header">fn <a href="#method.find_non_ascii_byte" class="fn">find_non_ascii_byte</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the index of the first non-ASCII byte in this byte string (if
any such indices exist). Specifically, it returns the index of the
first byte with a value greater than or equal to <code>0x80</code>.</p>
<h5 id="examples-57"><a href="#examples-57">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{ByteSlice, B};

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">3</span>), <span class="string">b&quot;abc\xff&quot;</span>.find_non_ascii_byte());
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="string">b&quot;abcde&quot;</span>.find_non_ascii_byte());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">0</span>), B(<span class="string">&quot;😀&quot;</span>).find_non_ascii_byte());</code></pre></div>
</div></details></div><h2 id="foreign-impls" class="small-section-header">Implementations on Foreign Types<a href="#foreign-impls" class="anchor">§</a></h2><section id="impl-ByteSlice-for-%5Bu8;+N%5D" class="impl"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#91-101">source</a><a href="#impl-ByteSlice-for-%5Bu8;+N%5D" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="trait.ByteSlice.html" title="trait bstr::ByteSlice">ByteSlice</a> for [<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>; <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.array.html">N</a>]</h3></section><section id="impl-ByteSlice-for-%5Bu8%5D" class="impl"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#79-89">source</a><a href="#impl-ByteSlice-for-%5Bu8%5D" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="trait.ByteSlice.html" title="trait bstr::ByteSlice">ByteSlice</a> for [<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>]</h3></section><h2 id="implementors" class="small-section-header">Implementors<a href="#implementors" class="anchor">§</a></h2><div id="implementors-list"></div><script src="../implementors/bstr/ext_slice/trait.ByteSlice.js" data-ignore-extern-crates="std" async></script><script type="text/json" id="notable-traits-data">{"&[u8]":"<h3>Notable traits for <code>&amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.74.1/std/primitive.u8.html\">u8</a>]</code></h3><pre><code><span class=\"where fmt-newline\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.74.1/std/io/trait.Read.html\" title=\"trait std::io::Read\">Read</a> for &amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.74.1/std/primitive.u8.html\">u8</a>]</span>","Bytes<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.Bytes.html\" title=\"struct bstr::Bytes\">Bytes</a>&lt;'a&gt;</code></h3><pre><code><span class=\"where fmt-newline\">impl&lt;'a&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.74.1/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Bytes.html\" title=\"struct bstr::Bytes\">Bytes</a>&lt;'a&gt;</span><span class=\"where fmt-newline\">    type <a href=\"https://doc.rust-lang.org/1.74.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.74.1/std/primitive.u8.html\">u8</a>;</span>","CharIndices<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.CharIndices.html\" title=\"struct bstr::CharIndices\">CharIndices</a>&lt;'a&gt;</code></h3><pre><code><span class=\"where fmt-newline\">impl&lt;'a&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.74.1/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.CharIndices.html\" title=\"struct bstr::CharIndices\">CharIndices</a>&lt;'a&gt;</span><span class=\"where fmt-newline\">    type <a href=\"https://doc.rust-lang.org/1.74.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = (<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.74.1/std/primitive.usize.html\">usize</a>, <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.74.1/std/primitive.usize.html\">usize</a>, <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.74.1/std/primitive.char.html\">char</a>);</span>","Chars<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.Chars.html\" title=\"struct bstr::Chars\">Chars</a>&lt;'a&gt;</code></h3><pre><code><span class=\"where fmt-newline\">impl&lt;'a&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.74.1/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Chars.html\" title=\"struct bstr::Chars\">Chars</a>&lt;'a&gt;</span><span class=\"where fmt-newline\">    type <a href=\"https://doc.rust-lang.org/1.74.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.74.1/std/primitive.char.html\">char</a>;</span>","EscapeBytes<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.EscapeBytes.html\" title=\"struct bstr::EscapeBytes\">EscapeBytes</a>&lt;'a&gt;</code></h3><pre><code><span class=\"where fmt-newline\">impl&lt;'a&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.74.1/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.EscapeBytes.html\" title=\"struct bstr::EscapeBytes\">EscapeBytes</a>&lt;'a&gt;</span><span class=\"where fmt-newline\">    type <a href=\"https://doc.rust-lang.org/1.74.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.74.1/std/primitive.char.html\">char</a>;</span>","FieldsWith<'_, F>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.FieldsWith.html\" title=\"struct bstr::FieldsWith\">FieldsWith</a>&lt;'a, F&gt;</code></h3><pre><code><span class=\"where fmt-newline\">impl&lt;'a, F: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.74.1/core/ops/function/trait.FnMut.html\" title=\"trait core::ops::function::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.74.1/std/primitive.char.html\">char</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.74.1/std/primitive.bool.html\">bool</a>&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.74.1/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.FieldsWith.html\" title=\"struct bstr::FieldsWith\">FieldsWith</a>&lt;'a, F&gt;</span><span class=\"where fmt-newline\">    type <a href=\"https://doc.rust-lang.org/1.74.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.74.1/std/primitive.u8.html\">u8</a>];</span>","Find<'h, 'n>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.Find.html\" title=\"struct bstr::Find\">Find</a>&lt;'h, 'n&gt;</code></h3><pre><code><span class=\"where fmt-newline\">impl&lt;'h, 'n&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.74.1/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Find.html\" title=\"struct bstr::Find\">Find</a>&lt;'h, 'n&gt;</span><span class=\"where fmt-newline\">    type <a href=\"https://doc.rust-lang.org/1.74.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.74.1/std/primitive.usize.html\">usize</a>;</span>","FindReverse<'h, 'n>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.FindReverse.html\" title=\"struct bstr::FindReverse\">FindReverse</a>&lt;'h, 'n&gt;</code></h3><pre><code><span class=\"where fmt-newline\">impl&lt;'h, 'n&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.74.1/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.FindReverse.html\" title=\"struct bstr::FindReverse\">FindReverse</a>&lt;'h, 'n&gt;</span><span class=\"where fmt-newline\">    type <a href=\"https://doc.rust-lang.org/1.74.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.74.1/std/primitive.usize.html\">usize</a>;</span>","Lines<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.Lines.html\" title=\"struct bstr::Lines\">Lines</a>&lt;'a&gt;</code></h3><pre><code><span class=\"where fmt-newline\">impl&lt;'a&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.74.1/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Lines.html\" title=\"struct bstr::Lines\">Lines</a>&lt;'a&gt;</span><span class=\"where fmt-newline\">    type <a href=\"https://doc.rust-lang.org/1.74.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.74.1/std/primitive.u8.html\">u8</a>];</span>","LinesWithTerminator<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.LinesWithTerminator.html\" title=\"struct bstr::LinesWithTerminator\">LinesWithTerminator</a>&lt;'a&gt;</code></h3><pre><code><span class=\"where fmt-newline\">impl&lt;'a&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.74.1/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.LinesWithTerminator.html\" title=\"struct bstr::LinesWithTerminator\">LinesWithTerminator</a>&lt;'a&gt;</span><span class=\"where fmt-newline\">    type <a href=\"https://doc.rust-lang.org/1.74.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.74.1/std/primitive.u8.html\">u8</a>];</span>","Split<'h, 's>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.Split.html\" title=\"struct bstr::Split\">Split</a>&lt;'h, 's&gt;</code></h3><pre><code><span class=\"where fmt-newline\">impl&lt;'h, 's&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.74.1/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Split.html\" title=\"struct bstr::Split\">Split</a>&lt;'h, 's&gt;</span><span class=\"where fmt-newline\">    type <a href=\"https://doc.rust-lang.org/1.74.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'h [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.74.1/std/primitive.u8.html\">u8</a>];</span>","SplitN<'h, 's>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.SplitN.html\" title=\"struct bstr::SplitN\">SplitN</a>&lt;'h, 's&gt;</code></h3><pre><code><span class=\"where fmt-newline\">impl&lt;'h, 's&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.74.1/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.SplitN.html\" title=\"struct bstr::SplitN\">SplitN</a>&lt;'h, 's&gt;</span><span class=\"where fmt-newline\">    type <a href=\"https://doc.rust-lang.org/1.74.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'h [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.74.1/std/primitive.u8.html\">u8</a>];</span>","SplitNReverse<'h, 's>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.SplitNReverse.html\" title=\"struct bstr::SplitNReverse\">SplitNReverse</a>&lt;'h, 's&gt;</code></h3><pre><code><span class=\"where fmt-newline\">impl&lt;'h, 's&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.74.1/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.SplitNReverse.html\" title=\"struct bstr::SplitNReverse\">SplitNReverse</a>&lt;'h, 's&gt;</span><span class=\"where fmt-newline\">    type <a href=\"https://doc.rust-lang.org/1.74.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'h [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.74.1/std/primitive.u8.html\">u8</a>];</span>","SplitReverse<'h, 's>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.SplitReverse.html\" title=\"struct bstr::SplitReverse\">SplitReverse</a>&lt;'h, 's&gt;</code></h3><pre><code><span class=\"where fmt-newline\">impl&lt;'h, 's&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.74.1/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.SplitReverse.html\" title=\"struct bstr::SplitReverse\">SplitReverse</a>&lt;'h, 's&gt;</span><span class=\"where fmt-newline\">    type <a href=\"https://doc.rust-lang.org/1.74.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'h [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.74.1/std/primitive.u8.html\">u8</a>];</span>","Utf8Chunks<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.Utf8Chunks.html\" title=\"struct bstr::Utf8Chunks\">Utf8Chunks</a>&lt;'a&gt;</code></h3><pre><code><span class=\"where fmt-newline\">impl&lt;'a&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.74.1/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Utf8Chunks.html\" title=\"struct bstr::Utf8Chunks\">Utf8Chunks</a>&lt;'a&gt;</span><span class=\"where fmt-newline\">    type <a href=\"https://doc.rust-lang.org/1.74.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"struct\" href=\"struct.Utf8Chunk.html\" title=\"struct bstr::Utf8Chunk\">Utf8Chunk</a>&lt;'a&gt;;</span>","Vec<u8>":"<h3>Notable traits for <code><a class=\"struct\" href=\"https://doc.rust-lang.org/1.74.1/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.74.1/std/primitive.u8.html\">u8</a>, A&gt;</code></h3><pre><code><span class=\"where fmt-newline\">impl&lt;A&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.74.1/std/io/trait.Write.html\" title=\"trait std::io::Write\">Write</a> for <a class=\"struct\" href=\"https://doc.rust-lang.org/1.74.1/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.74.1/std/primitive.u8.html\">u8</a>, A&gt;<span class=\"where fmt-newline\">where\n    A: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.74.1/core/alloc/trait.Allocator.html\" title=\"trait core::alloc::Allocator\">Allocator</a>,</span></span>"}</script></section></div></main></body></html>