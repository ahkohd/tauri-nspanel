searchState.loadedDescShard("hyper_util", 0, "Utilities for working with hyper.\nHTTP client utilities\nRuntime utilities\nService utilities.\nLegacy implementations of <code>connect</code> module and <code>Client</code>\nA builder to configure a new <code>Client</code>.\nA Client to make outgoing HTTP requests.\nClient errors\nA <code>Future</code> that will resolve to an HTTP Response.\nCombine the configuration of this builder with a connector …\nBuild a client with this configuration and the default …\nCreate a builder to configure a new <code>Client</code>.\nConnectors used by the <code>Client</code>.\nReturns the info of the client connection on which this …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nSend a <code>GET</code> request to the supplied <code>Uri</code>.\nSet whether HTTP/0.9 responses should be tolerated.\nSet whether HTTP/1 connections will accept obsolete line …\nSet whether HTTP/1 connections will accept spaces between …\nSets whether invalid header lines should be silently …\nSet the maximum buffer size for the connection.\nSet the maximum number of headers.\nSet whether to support preserving original header cases.\nSets the exact size of the read buffer to <em>always</em> use.\nSet whether HTTP/1 connections will write header names as …\nSet whether HTTP/1 connections should try to use vectored …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if this was an error from <code>Connect</code>.\nConstruct a new Builder.\nSet an optional timeout for idle sockets being kept-alive. …\nSets the maximum idle connection per host allowed in the …\nProvide a timer to be used for timeouts and intervals in …\nSend a constructed <code>Request</code> using this <code>Client</code>.\nSet whether to retry requests that get disrupted before …\nSet whether to automatically add the <code>Host</code> header to …\nProvide a timer to be used for h2\n<code>CaptureConnection</code> allows callers to capture <code>Connected</code> …\nConnect to a destination, returning an IO transport.\nExtra information about the connected transport.\nDescribes a type returned by a connector.\nA connector for the <code>http</code> scheme.\nExtra information about the transport when an …\nCapture the connection for a given request\nReturn metadata describing the connection.\nRetrieve the connection metadata, if available\nDNS Resolution used by the <code>HttpConnector</code>.\nOption to enforce all <code>Uri</code>s have the <code>http</code> scheme.\nSet extra connection information to be set in the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCopies the extra connection information into an <code>Extensions</code> …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDetermines if the connected transport negotiated HTTP/2 as …\nDetermines if the connected transport is to an HTTP proxy.\nGet the local address of the transport used.\nSet that the connected transport negotiated HTTP/2 as its …\nConstruct a new HttpConnector.\nCreate new <code>Connected</code> type with empty metadata.\nConstruct a new HttpConnector.\nPoison this connection\nSet whether the connected transport is to an HTTP proxy.\nGet the remote address of the transport used.\nSet the connect timeout.\nSet timeout for RFC 6555 (Happy Eyeballs) algorithm.\nSet that all sockets have <code>SO_KEEPALIVE</code> set with the …\nSet the duration between two successive TCP keepalive …\nSet the number of retransmissions to be carried out before …\nSet that all sockets are bound to the configured address …\nSet that all sockets are bound to the configured IPv4 or …\nSet that all sockets have <code>SO_NODELAY</code> set to the supplied …\nSets the value of the SO_RCVBUF option on the socket.\nSet that all socket have <code>SO_REUSEADDR</code> set to the supplied …\nSets the value of the SO_SNDBUF option on the socket.\nWait for the connection to be established\nAn iterator of IP addresses returned from <code>getaddrinfo</code>.\nA future to resolve a name returned by <code>GaiResolver</code>.\nA resolver using blocking <code>getaddrinfo</code> calls in a …\nError indicating a given string was not a valid domain …\nA domain name to resolve into IP addresses.\nView the hostname as a string slice.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstruct a new <code>GaiResolver</code>.\nTokio IO integration for hyper\nFuture executor that utilises <code>tokio</code> threads.\nA wrapper that implements Tokio’s IO traits for an inner …\nA Timer that uses the tokio runtime.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nBorrow the inner type.\nMut borrow the inner type.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsume this wrapper and get the inner type.\nCreate new executor that relies on <code>tokio::spawn</code> to execute …\nWrap a type implementing Tokio’s or hyper’s IO traits.\nCreate a new TokioTimer")